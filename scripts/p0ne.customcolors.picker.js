// Generated by LiveScript 1.3.1
/*=====================*\
|* p0ne.customcolors.p *|
\*=====================*/
/*@source p0ne.customcolors.picker.ls */
/*
    user data format
    user = {
        uid: 00000000
        color: "#AABBCC"
        font: {b: true, i: false, u: null /*fallthrough* /}
        icon: {
            url: ""
            x: 0px
            y: 0px
        } <OR> "icon-chat-bouncer"
        badge: {
            url: ""
            x: 0px
            y: 0px
        } <OR> "bdg-raveb-s04"
    }
*/
var out$ = typeof exports != 'undefined' && exports || this;
module('customColorsPicker', {
  iconCache: {},
  rows: {},
  setup: function(arg$, ccp){
    var addListener, css, loadStyle, $create, cc, $el, ref$, key, ref1$, $roles, $input, i$, len$, roleName, icon, ref2$, d, scopeName, uid, drag_cb, drag_pos, imageDragInitPos, $cp, image, $css, tmpCSS, defaultIconURL, $cpp, $contentName, $contentImage, $nameCustomToggles, $newColor, $currentColor, $crosshair, $huePointer, $hex, $rgb, $hsv, $font, currentColor, customColor, color, colorHSV, font, nameCustomMode, $imageCustomToggles, $snapToGrid, $badgeGroup, $imagePicker, $cloak, $image, badge, scale, imageMode, snapToGrid, imageCustomMode, imagePicker, imageEl, urlUpdateTimeout, scope, $row, styleDefault, customImage, loadData, updateCSSTimeout, updateCSS, test, this$ = this;
    addListener = arg$.addListener, css = arg$.css, loadStyle = arg$.loadStyle, $create = arg$.$create;
    this.cc = cc = p0ne.modules.customColors;
    $el = cc != null ? (ref$ = cc._$settingsPanel) != null ? ref$.wrapper : void 8 : void 8;
    if (!cc || !$el) {
      return;
    }
    this.rows = {};
    this.lang = (ref1$ = clone$(Lang.roles), ref1$.friend = Lang.userList.friend, ref1$.subscriber = Lang.userStatus.subscriber, ref1$.regular = 'Regular', ref1$.you = 'You', ref1$);
    loadStyle(p0ne.host + "/css/customcolors.css?r=3");
    $el.addClass('p0ne-cc-settings').css({
      left: $('.p0ne-settings').width()
    }).html("<h3>Custom Colours</h3><div class=p0ne-cc-buttons><button class='p0ne-cc-reset-order-btn' disabled>reset order</button><button class='p0ne-cc-reset-all-btn'>reset everything</button></div><div class='p0ne-cc-roles'></div><div class='p0ne-cc-users'><div class=p0ne-cc-user-add><i class='icon icon-add p0ne-cc-user-add-icon'></i><input class='p0ne-settings-input p0ne-cc-user-input' placeholder='new custom user style' /><ul class=p0ne-cc-user-suggestion-list></ul></div></div>");
    $roles = $el.find('.p0ne-cc-roles');
    this.$add = $el.find('.p0ne-cc-user-add');
    $input = this.$add.find('.p0ne-cc-user-input');
    for (i$ = 0, len$ = (ref1$ = cc._settings.rolesOrder).length; i$ < len$; ++i$) {
      roleName = ref1$[i$];
      /*icon = false
      for scope in cc.scopeOrderRole when cc.scopes[scope][roleName]?.icon
          icon = cc.scopes[scope][roleName].icon
          break*/
      icon = cc.roles[roleName].icon || cc.roles.regular.icon;
      if (typeof icon === 'string') {
        (ref2$ = this.iconCache)[icon] || (ref2$[icon] = getIcon(icon, true));
      }
      $("<div class='p0ne-cc-row p0ne-cc-name p0ne-name " + roleName + "' data-scope=globalCustomRole data-key=" + roleName + "><i class='icon icon-drag-handle p0ne-cc-drag-handle'></i>" + this.createIcon(icon) + "<span class=name>" + (this.lang[roleName] || roleName) + "</span><i class='icon icon-clear-input p0ne-cc-clear-icon'></i></div>").appendTo($roles);
    }
    d = Date.now();
    for (i$ = 0, len$ = (ref1$ = cc.scopeOrderUser).length; i$ < len$; ++i$) {
      scopeName = ref1$[i$];
      for (uid in cc.scopes[scopeName]) {
        this.createUser(uid, false, d);
      }
    }
    $el.on('click', '.p0ne-cc-reset-all-btn', function(e){
      var objectsToClear, i$, len$, obj, key;
      e.preventDefault();
      objectsToClear = [cc.scopes.globalCustomUser, cc.scopes.globalCustomRole, cc._settings.users, cc._settings.perRoom];
      for (i$ = 0, len$ = objectsToClear.length; i$ < len$; ++i$) {
        obj = objectsToClear[i$];
        for (key in obj) {
          delete obj[key];
        }
      }
      ccp.disable();
      cc.disable().enable()._$settings.find('.p0ne-settings-panel-icon').click();
    }).on('click', '.p0ne-cc-row', function(e){
      var $row, scope, row_key, style;
      $el.find('.p0ne-cc-row.selected').removeClass('selected');
      $row = $(this).addClass('selected');
      scope = $row.data('scope');
      row_key = $row.data('key');
      if (!(style = cc.scopes[scope][row_key])) {
        style = cc.scopes[scope][row_key] = {};
      }
      if (key) {
        ccp.save();
      }
      ccp.loadData(scope, row_key, $row);
      e.stopImmediatePropagation();
    }).on('click', '.p0ne-cc-clear-icon', function(e){
      var $row, scope, row_key, removeUserCache, i$, ref$, len$, scopeName;
      $row = $(this).closest('.p0ne-cc-row');
      scope = $row.data('scope');
      row_key = $row.data('key');
      delete cc.scopes[scope][row_key];
      if (scope === 'globalCustomUser') {
        removeUserCache = true;
        for (i$ = 0, len$ = (ref$ = cc.scopeOrderUser).length; i$ < len$; ++i$) {
          scopeName = ref$[i$];
          if (row_key in cc.scopes[scopeName]) {
            removeUserCache = false;
            break;
          }
        }
        if (removeUserCache) {
          delete cc.users[row_key];
          delete ccp.rows[row_key];
          $row.remove();
        }
      }
      if (key === row_key) {
        key = "";
        ccp.close();
      }
      cc.updateCSS();
      e.stopImmediatePropagation();
    });
    $input.on('keydown', function(e){
      var t;
      t = e.which || e.keyCode;
      if ((deepEq$(t, 13, '===') || deepEq$(t, 9, '===')) && this$.sugg.suggestions.length > 0) {
        this$.sugg.trigger('submitSuggestion');
      } else if ((deepEq$(t, 40, '===') || deepEq$(t, 38, '===')) && this$.sugg.suggestions.length > 0) {
        this$.sugg.upDown(t);
      } else {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
    }).on('keyup', function(e){
      ccp.sugg.check("@" + this.value, this.value.length + 1);
      ccp.sugg.updateSuggestions();
    });
    out$.sugg = this.sugg = new SuggestionView();
    this.sugg.$el.insertBefore(this.$add.children().first());
    this.sugg.render().on('refocus', function(){
      $input.focus();
    }).on('submitSuggestion', function(){
      var user, scope;
      user = getUser(this$.sugg.getSelected());
      if (!user) {
        return;
      }
      $input.val("");
      scope = cc.scopes.globalCustomUser;
      if (scope[user.id]) {
        this$.rows[user.id].click();
      } else {
        scope[user.id] = {};
        this$.createUser(user.id).click();
      }
    });
    cc.updateCSS();
    out$.onDrag = onDrag;
    function onDrag(target, cb, onMouseDown){
      return cc.addListener($el, 'mousedown', target, function(e){
        drag_cb = cb;
        drag_pos = $(this).offset();
        if (onMouseDown) {
          onMouseDown.call(this, e, drag_pos);
        }
        drag_mousemove.call(this, e);
        $body.on('mouseup', drag_mouseup).on('mousemove', drag_mousemove);
        return e.preventDefault();
      });
    }
    function drag_mouseup(){
      return $body.off('mouseup', drag_mouseup).off('mousemove', drag_mousemove);
    }
    function drag_mousemove(e){
      drag_cb.call(this, e.pageX - drag_pos.left, e.pageY - drag_pos.top, e);
      return e.preventDefault();
    }
    $el.append(this.$cp = $cp = $('<div class=colorpicker><div class="p0ne-ccp-tabbar"><div class="p0ne-ccp-tab-name">Name</div><div class="p0ne-ccp-tab-icon p0ne-ccp-tab-selected">Icon</div><div class="p0ne-ccp-tab-badge">Badge</div></div><div class="p0ne-ccp-content-name"><div class="p0ne-ccp-group p0ne-ccp-group-custom-toggle"><button class="p0ne-ccp-btn-toggle" data-mode=default>default</button><button class="p0ne-ccp-btn-toggle" data-mode=custom>custom</button></div><div class="p0ne-ccp-group p0ne-ccp-group-picker"><div class="p0ne-ccp-color"><div class="p0ne-cpp-color-overlay"><div class="p0ne-ccp-crosshair"></div></div></div><div class="p0ne-ccp-hue" style="background: url(https://dl.dropboxusercontent.com/u/4217628/plug_p0ne/vendor/colorpicker/images/slider.png); background-size: contain; background-repeat: no-repeat; background-position: center; "><div class="p0ne-ccp-hue-pointer"></div></div></div><div class="p0ne-ccp-group p0ne-ccp-group-hex"><div class="p0ne-ccp-new-color">new</div><div class="p0ne-ccp-current-color">previous</div><div class="p0ne-ccp-field p0ne-ccp-hex"><input type=text maxlength=6 /></div></div><div class="p0ne-ccp-group p0ne-ccp-group-rgb"><div class="p0ne-ccp-field p0ne-ccp-r"><input type=text maxlength=3 /></div><div class="p0ne-ccp-field p0ne-ccp-g"><input type=text maxlength=3 /></div><div class="p0ne-ccp-field p0ne-ccp-b"><input type=text maxlength=3 /></div></div><div class="p0ne-ccp-group p0ne-ccp-group-hsv"><div class="p0ne-ccp-field p0ne-ccp-h"><input type=text maxlength=3 /></div><div class="p0ne-ccp-field p0ne-ccp-s"><input type=text maxlength=3 /></div><div class="p0ne-ccp-field p0ne-ccp-v"><input type=text maxlength=3 /></div></div><div class="p0ne-ccp-group p0ne-ccp-group-btns"><button class="p0ne-ccp-btn-b">b</button><button class="p0ne-ccp-btn-i">i</button><button class="p0ne-ccp-btn-u">u</button><button class="p0ne-ccp-btn-reset">reset</button><button class="p0ne-ccp-btn-save">save</button></div></div><div class="p0ne-ccp-content-image"><div class="p0ne-ccp-group p0ne-ccp-group-custom-toggle"><button class="p0ne-ccp-btn-toggle" data-mode=none>none</button><button class="p0ne-ccp-btn-toggle" data-mode=default>default</button><button class="p0ne-ccp-btn-toggle" data-mode=custom>custom</button><br><label><input type=checkbox class="checkbox p0ne-ccp-snaptogrid" /> snap to grid</label></div><div class="p0ne-ccp-group p0ne-ccp-group-image-picker"><div class="p0ne-ccp-image-preview"><div class="p0ne-ccp-cloak-tl"></div><div class="p0ne-ccp-cloak-tr"></div><div class="p0ne-ccp-cloak-bl"></div><div class="p0ne-ccp-cloak-br"></div></div><div class="p0ne-ccp-image-overview"><div class="p0ne-ccp-image-rect"></div></div></div><div class="p0ne-ccp-group p0ne-ccp-group-image"><div class="p0ne-ccp-field p0ne-ccp-image-url"><input type=text placeholder="plug.dj default" /></div><button class="p0ne-ccp-btn-reset">reset</button><div class="p0ne-ccp-field p0ne-ccp-image-x"><input type=number /></div><div class="p0ne-ccp-field p0ne-ccp-image-y"><input type=number /></div></div><button class="p0ne-ccp-btn-save">save</button><div class="p0ne-ccp-group p0ne-ccp-group-badge"><div class="p0ne-ccp-field p0ne-ccp-image-w"><input type=number /></div><div class="p0ne-ccp-field p0ne-ccp-image-h"><input type=number /></div></div></div></div>'));
    $css = $create('<style>').appendTo('head');
    tmpCSS = true;
    defaultIconURL = getIcon('', true).url;
    $cpp = $cp.find('.p0ne-ccp-color');
    $contentName = $cp.find('.p0ne-ccp-content-name');
    $contentImage = $cp.find('.p0ne-ccp-content-image');
    addListener($cp, 'click', '.p0ne-ccp-tab-name, .p0ne-ccp-tab-icon, .p0ne-ccp-tab-badge', function(e){
      var $this;
      $this = $(this);
      $this.addClass('p0ne-ccp-tab-selected').siblings().removeClass('p0ne-ccp-tab-selected');
      if ($this.hasClass('p0ne-ccp-tab-name')) {
        $contentName.show();
        $contentImage.hide();
      } else {
        $contentName.hide();
        $contentImage.show();
        if ($this.hasClass('p0ne-ccp-tab-icon')) {
          setImageMode('icon');
        } else {
          setImageMode('badge');
        }
      }
      return e.preventDefault();
    });
    addListener($cp, 'click', '.p0ne-ccp-btn-save', function(){
      ccp.save();
    });
    $nameCustomToggles = $contentName.find('.p0ne-ccp-btn-toggle');
    $newColor = $cp.find('.p0ne-ccp-new-color');
    $currentColor = $cp.find('.p0ne-ccp-current-color');
    $crosshair = $cp.find('.p0ne-ccp-crosshair');
    $huePointer = $cp.find('.p0ne-ccp-hue-pointer');
    $hex = $cp.find(".p0ne-ccp-hex input");
    $rgb = {
      r: $cp.find(".p0ne-ccp-r input"),
      g: $cp.find(".p0ne-ccp-g input"),
      b: $cp.find(".p0ne-ccp-b input")
    };
    $hsv = {
      h: $cp.find(".p0ne-ccp-h input"),
      s: $cp.find(".p0ne-ccp-s input"),
      v: $cp.find(".p0ne-ccp-v input")
    };
    $font = {
      b: $cp.find('.p0ne-ccp-btn-b'),
      i: $cp.find('.p0ne-ccp-btn-i'),
      u: $cp.find('.p0ne-ccp-btn-u')
    };
    /*color =
        r: 0 #+$rgb.r .val!
        g: 0 #+$rgb.g .val!
        b: 0 #+$rgb.b .val!
    colorHSV =
        h: 0 #+$hsv.h .val!
        s: 0 #+$hsv.s .val!
        v: 0 #+$hsv.v .val!
    font =
        b: false #$font.b .hasClass \p0ne-ccp-btn-selected
        i: false #$font.i .hasClass \p0ne-ccp-btn-selected
        u: false #$font.u .hasClass \p0ne-ccp-btn-selected
    */
    addListener($nameCustomToggles, 'click', function(){
      var $this;
      $this = $(this);
      if (!$this.hasClass('selected')) {
        $nameCustomToggles.removeClass('selected');
        $this.addClass('selected');
        switch ($(this).data('mode')) {
        case 'default':
          customColor = getHex();
          $hex.val(styleDefault.color).trigger('input');
          nameCustomMode = 'default';
          break;
        case 'custom':
          nameCustomMode = 'custom';
          $hex.val(customColor).trigger('input');
        }
        return updateCSS();
      }
    });
    onDrag('.p0ne-ccp-color', function(x, y){
      var ref$;
      $hsv.s.val(Math.round(((ref$ = 0 > x ? 0 : x) < 150 ? ref$ : 150) * 100 / 150));
      $hsv.v.val(100 - Math.round(((ref$ = 0 > y ? 0 : y) < 150 ? ref$ : 150) * 100 / 150));
      return inputHSV();
    });
    onDrag('.p0ne-ccp-hue', function(arg$, y){
      var ref$;
      $hsv.h.val(colorHSV.h = 360 - Math.round(((ref$ = 0 > y ? 0 : y) < 150 ? ref$ : 150) * 360 / 150));
      return inputHSV();
    });
    addListener($cp, 'input', '.p0ne-ccp-hex input', inputHex);
    addListener($cp, 'blur', '.p0ne-ccp-hex input', updateUI);
    addListener($cp, 'input', '.p0ne-ccp-group-rgb input', function(){
      checkNameCustomMode();
      color.r = +$rgb.r.val();
      color.g = +$rgb.g.val();
      color.b = +$rgb.b.val();
      return inputRGB();
    });
    addListener($cp, 'input', '.p0ne-ccp-group-hsv input', function(){
      colorHSV.h = +$hsv.h.val();
      colorHSV.s = +$hsv.s.val();
      colorHSV.v = +$hsv.v.val();
      return inputHSV();
    });
    addListener($cp, 'click', '.p0ne-ccp-group-btns button', function(e){
      var $this, btn;
      $this = $(this);
      btn = $this.hasClass('p0ne-ccp-btn-b')
        ? 'b'
        : $this.hasClass('p0ne-ccp-btn-i')
          ? 'i'
          : $this.hasClass('p0ne-ccp-btn-u') ? 'u' : void 8;
      if (!btn) {
        return;
      }
      if ($this.hasClass('p0ne-ccp-btn-selected')) {
        font[btn] = false;
        $this.removeClass('p0ne-ccp-btn-selected p0ne-ccp-btn-default p0ne-ccp-btn-default-selected');
        /*else if font[btn] = not $this.hasClass \p0ne-ccp-btn-default
            # set to default
            delete font[btn]
            $this .addClass \p0ne-ccp-btn-selected
            if styleDefault.font[btn] # default value is in font.__proto__[btn]
                $this .addClass \p0ne-ccp-btn-default-selected */
      } else {
        font[btn] = true;
        $this.addClass('p0ne-ccp-btn-selected');
      }
      updateUI();
      return e.preventDefault();
    });
    addListener($cp, 'click', '.p0ne-ccp-content-name .p0ne-ccp-btn-reset', function(e){
      var btn, ref$, state;
      $hex.val(currentColor);
      inputHex();
      delete font.b, delete font.i, delete font.u;
      for (btn in ref$ = font) {
        state = ref$[btn];
        if (state) {
          $font[btn].addClass('p0ne-ccp-btn-selected');
        } else {
          $font[btn].removeClass('p0ne-ccp-btn-selected');
        }
      }
      return e.preventDefault();
    });
    function inputHSV(){
      checkNameCustomMode();
      colorHSV = {
        h: ~~$hsv.h.val(),
        s: ~~$hsv.s.val(),
        v: ~~$hsv.v.val()
      };
      color = hsvToRgb(colorHSV);
      $rgb.r.val(color.r);
      $rgb.g.val(color.g);
      $rgb.b.val(color.b);
      return updateUI(true);
    }
    function inputRGB(){
      checkNameCustomMode();
      color = {
        r: ~~$rgb.r.val(),
        g: ~~$rgb.g.val(),
        b: ~~$rgb.b.val()
      };
      colorHSV = rgbToHsv(color);
      $hsv.h.val(colorHSV.h);
      $hsv.s.val(colorHSV.s);
      $hsv.v.val(colorHSV.v);
      return updateUI(true);
    }
    function inputHex(){
      var val_, val, res$, i$, to$, char, r, g, b;
      checkNameCustomMode();
      val_ = $.trim($hex.val());
      res$ = [];
      for (i$ = val_[0] === '#' ? 1 : 0, to$ = val_.length; i$ < to$; ++i$) {
        char = i$;
        res$.push(parseInt(val_[char], 16));
      }
      val = res$;
      switch (val.length) {
      case 1:
        r = g = b = 16 * val + +val;
        break;
      case 2:
        r = g = b = val;
        break;
      case 3:
        r = 16 * val[0] + +val[0];
        g = 16 * val[1] + +val[1];
        b = 16 * val[2] + +val[2];
        break;
      case 4:
        r = 16 * val[0] + +val[1];
        g = 16 * val[2] + +val[3];
        b = 0;
        break;
      case 5:
        r = 16 * val[0] + +val[1];
        g = 16 * val[2] + +val[3];
        b = 16 * val[4];
        break;
      default:
        r = 16 * val[0] + +val[1];
        g = 16 * val[2] + +val[3];
        b = 16 * val[4] + +val[5];
      }
      color = {
        r: r,
        g: g,
        b: b
      };
      $rgb.r.val(r);
      $rgb.g.val(g);
      $rgb.b.val(b);
      colorHSV = rgbToHsv(color);
      $hsv.h.val(colorHSV.h);
      $hsv.s.val(colorHSV.s);
      $hsv.v.val(colorHSV.v);
      return updateUI(false);
    }
    function getHex(){
      return "" + padHex(color.r.toString(16)) + "" + padHex(color.g.toString(16)) + "" + padHex(color.b.toString(16)) + "";
    }
    function updateUI(updateHex){
      var hexVal;
      hexVal = getHex();
      if (updateHex) {
        $hex.val(hexVal.toUpperCase());
      }
      hexVal = "#" + hexVal;
      $crosshair.css({
        left: colorHSV.s * 150 / 100,
        top: 150 - colorHSV.v * 150 / 100
      });
      $huePointer.css({
        top: 150 - colorHSV.h * 150 / 360
      });
      $cpp.css({
        background: "hsl(" + colorHSV.h + ", 100%, 50%)"
      });
      $newColor.css({
        background: hexVal
      });
      return updateCSS();
    }
    function checkNameCustomMode(){
      if (nameCustomMode === 'default') {
        nameCustomMode = 'custom';
        return $nameCustomToggles.removeClass('selected').filter('[data-mode=custom]').addClass('selected');
      }
    }
    $imageCustomToggles = $contentImage.find('.p0ne-ccp-btn-toggle');
    $snapToGrid = $contentImage.find('.p0ne-ccp-snaptogrid');
    $badgeGroup = $cp.find('.p0ne-ccp-group-badge');
    $imagePicker = {
      preview: $cp.find('.p0ne-ccp-image-preview'),
      overview: $cp.find('.p0ne-ccp-image-overview'),
      rect: $cp.find('.p0ne-ccp-image-rect')
    };
    $cloak = {
      tl: $cp.find('.p0ne-ccp-cloak-tl'),
      tr: $cp.find('.p0ne-ccp-cloak-tr'),
      bl: $cp.find('.p0ne-ccp-cloak-bl'),
      br: $cp.find('.p0ne-ccp-cloak-br')
    };
    $image = {
      url: $cp.find(".p0ne-ccp-image-url input"),
      x: $cp.find(".p0ne-ccp-image-x input"),
      y: $cp.find(".p0ne-ccp-image-y input"),
      w: $cp.find(".p0ne-ccp-image-w input"),
      h: $cp.find(".p0ne-ccp-image-h input")
    };
    snapToGrid = {
      w_2: 5,
      h_2: 5
    };
    imageCustomMode = {};
    imagePicker = {
      marginLeft: 0,
      marginTop: 0
    };
    imageEl = new Image;
    imageEl.onload = updateImage;
    imageEl.onerror = updateImageOnError;
    addListener($imageCustomToggles, 'click', function(){
      var $this;
      $this = $(this);
      if (!$this.hasClass('selected')) {
        $imageCustomToggles.removeClass('selected');
        $this.addClass('selected');
        switch (imageCustomMode[imageMode] = $(this).data('mode')) {
        case 'none':
          $contentImage.addClass('disabled');
          return $contentImage.find('input').attr('disabled', true);
        case 'default':
          $contentImage.removeClass('disabled');
          $contentImage.find('input').attr('disabled', null);
          return setImageMode('default');
        case 'custom':
          $contentImage.removeClass('disabled');
          $contentImage.find('input').attr('disabled', null);
          return setImageMode('custom');
        }
      }
    });
    addListener($snapToGrid, 'click', function(){
      console.log("snapToGrid", this.checked);
      snapToGrid = this.checked ? {
        w_2: ~~(image.w / 2 / 5) * 5,
        h_2: ~~(image.h / 2 / 5) * 5
      } : false;
    });
    onDrag('.p0ne-ccp-image-overview', function(x, y, e){
      if (checkImageCustomMode()) {
        return;
      }
      x = ~~((x - imagePicker.marginLeft) / scale) - image.w / 2;
      y = ~~((y - imagePicker.marginTop) / scale) - image.h / 2;
      if (snapToGrid) {
        x = Math.round(x / snapToGrid.w_2) * snapToGrid.w_2;
        y = Math.round(y / snapToGrid.h_2) * snapToGrid.h_2;
      }
      updateImagePos(x, y);
      return updateImageVal();
    });
    onDrag('.p0ne-ccp-image-preview', function(x, y, e){
      if (checkImageCustomMode()) {
        return;
      }
      if (snapToGrid) {
        x = Math.round(x / snapToGrid.w_2) * snapToGrid.w_2;
        y = Math.round(y / snapToGrid.h_2) * snapToGrid.h_2;
      }
      updateImagePos(-x, -y);
      updateImageVal();
    }, function(e, drag_pos){
      drag_pos.left = e.pageX + image.x;
      drag_pos.top = e.pageY + image.y;
    });
    addListener($cp, 'input keyup', '.p0ne-ccp-group-image input', function(){
      var x, y, this$ = this;
      if (checkImageCustomMode()) {
        return;
      }
      console.log("input", this, this.value);
      if ($(this).parent().hasClass('p0ne-ccp-image-url')) {
        clearTimeout(urlUpdateTimeout);
        console.log(">", this.value);
        return urlUpdateTimeout = sleep(500, function(){
          console.log(">>", this$.value);
          return loadImage(this$.value);
        });
      } else {
        x = +$image.x.val();
        y = +$image.y.val();
        if (isFinite(x) && isFinite(y)) {
          return updateImagePos(x, y);
        }
      }
    });
    addListener($cp, 'input', '.p0ne-ccp-group-badge input', function(){
      var w, h;
      if (checkImageCustomMode()) {
        return;
      }
      w = ~~$image.w.val();
      h = ~~$image.h.val();
      if (w > 0 && h > 0) {
        return updateImageSize(w, h);
      }
    });
    addListener($cp, 'click', '.p0ne-ccp-content-image .p0ne-ccp-btn-reset', function(e){
      var k;
      if (imageCustomMode[imageMode] === 'custom') {
        for (k in image) {
          delete image[k];
        }
        if (image === icon) {
          setImageMode('icon');
        } else {
          setImageMode('badge');
        }
      }
      return e.preventDefault();
    });
    function updateImagePos(x, y){
      var ref$, ref1$, ref2$, x2, y2;
      if (image.srcW) {
        x = (ref$ = 0 > (ref2$ = ~~x) ? 0 : ref2$) < (ref1$ = image.srcW - image.w) ? ref$ : ref1$;
        y = (ref$ = 0 > (ref2$ = ~~y) ? 0 : ref2$) < (ref1$ = image.srcH - image.h) ? ref$ : ref1$;
      }
      x2 = x / imagePicker.scale - 50 + image.w / (2 * imagePicker.scale);
      y2 = y / imagePicker.scale - 100 + image.h / (2 * imagePicker.scale);
      $imagePicker.preview.css({
        backgroundPosition: (-x2) + "px " + (-y2) + "px"
      });
      $imagePicker.rect.css({
        left: (x2 * scale + imagePicker.marginLeft) * imagePicker.scale,
        top: (y2 * scale + imagePicker.marginTop) * imagePicker.scale
      });
      image.x = x;
      image.y = y;
      return updateCSS();
    }
    function updateImageVal(){
      $image.x.val(image.x);
      $image.y.val(image.y);
      if (image === badge) {
        $image.w.val(image.w);
        return $image.h.val(image.h);
      }
    }
    function updateImageSize(w, h){
      var w_2, h_2, w_px, h_px;
      image.w = w;
      image.h = h;
      $image.w.val(w);
      $image.h.val(h);
      imagePicker.scale = Math.ceil((w > h ? w : h) / 100);
      w_2 = ~~(image.w / (imagePicker.scale * 2));
      h_2 = ~~(image.h / (imagePicker.scale * 2));
      console.log("updating size", w, h, imagePicker.scale + "x");
      imagePicker.rectW = 100 * scale * imagePicker.scale;
      imagePicker.rectH = 200 * scale * imagePicker.scale;
      if (snapToGrid) {
        snapToGrid = {
          w_2: ~~(w / 2 / 5) * 5,
          h_2: ~~(h / 2 / 5) * 5
        };
      }
      w_px = +(image.w / imagePicker.scale % 2 === 1);
      h_px = +(image.h / imagePicker.scale % 2 === 1);
      $cloak.tl.css({
        width: 50 + w_2 + w_px,
        height: 99 - h_2
      });
      $cloak.tr.css({
        width: 49 - w_2,
        height: 100 + h_2 + h_px,
        left: 50 + w_2 + w_px
      });
      $cloak.bl.css({
        width: 49 - w_2,
        height: 100 + h_2,
        top: 100 - h_2
      });
      $cloak.br.css({
        width: 50 + w_2,
        height: 99 - h_2,
        top: 100 + h_2 + h_px,
        left: 50 - w_2
      });
      if (image.srcW) {
        updateImagePicker();
      }
      updateImagePos(image.x, image.y);
      return updateCSS();
    }
    function updateImagePicker(){
      console.log("[updateImagePicker]", imagePicker.rectW, imagePicker.rectH);
      $imagePicker.preview.css({
        backgroundSize: image.srcW / imagePicker.scale + "px " + image.srcH / imagePicker.scale + "px"
      });
      return $imagePicker.rect.css({
        width: imagePicker.rectW,
        height: imagePicker.rectH
      });
    }
    function setImageMode(mode){
      switch (mode) {
      case 'icon':
        imageMode = 'icon';
        image = icon;
        $badgeGroup.hide();
        break;
      case 'badge':
        imageMode = 'badge';
        image = badge;
        $badgeGroup.show();
        break;
      default:
        switch (imageCustomMode[imageMode] = mode) {
        case 'default':
          image = styleDefault[imageMode];
          break;
        case 'custom':
          image = customImage[imageMode];
        }
      }
      console.log("set image mode", imageMode, "=>", mode, image);
      $imageCustomToggles.removeClass('selected').filter("[data-mode=" + imageCustomMode[imageMode] + "]").addClass('selected');
      loadImage(image.url);
      updateImageVal();
      return updateCSS();
    }
    function loadImage(url){
      if (!url) {
        return console.error("invalid image URL: " + url);
      } else {
        console.log("loading image " + url);
        image.url = url;
        if (url !== imageEl.src) {
          $image.url.val(image.url || defaultIconURL);
          imageEl.isLoaded = false;
          imageEl.src = url;
          return true;
        } else {
          updateImage.call(imageEl);
          return false;
        }
      }
    }
    function updateImage(){
      var ref$, ref1$;
      image.isLoaded = true;
      image.src_ = image.src;
      image.srcW = this.width;
      image.srcH = this.height;
      if (image.src === $image.url.val()) {
        $image.url.removeClass('error');
      }
      scale = (ref$ = 100 / this.width) < (ref1$ = 200 / this.height) ? ref$ : ref1$;
      imagePicker = {
        rectW: 100 * scale,
        rectH: 200 * scale,
        marginLeft: 50 - this.width * scale / 2,
        marginTop: 100 - this.height * scale / 2
      };
      updateImagePos(image.x, image.y);
      updateImageSize(image.w, image.h);
      $imagePicker.preview.css({
        backgroundImage: "url(" + this.src + ")"
      });
      $imagePicker.overview.css({
        backgroundImage: "url(" + this.src + ")"
      });
      return updateCSS();
    }
    function updateImageOnError(){
      if (image.src !== '') {
        $image.url.addClass('error');
        return console.warn("error loading image", image.src);
      }
    }
    function checkImageCustomMode(){
      if (imageCustomMode[imageMode] === 'default') {
        image = import$(customImage[imageMode], image);
        if (imageMode === 'icon') {
          icon = image;
        } else {
          badge = image;
        }
        imageCustomMode[imageMode] = 'custom';
        return $imageCustomToggles.removeClass('selected').filter('[data-mode=custom]').addClass('selected');
      } else if (imageCustomMode[imageMode] === 'none') {
        return true;
      }
    }
    customImage = {};
    this.loadData = loadData = function(scopeName, key_, $row_){
      /* note: the reason we clone$ the variables (font, icon, badge)
       * is so that the initial values are stored in the prototype of the
       * variables, not the in variables themselves
       * this way the reset button can delete the custom properties
       * which will than default back to the initial values
       */
      var data, badgeTemplate, ref$, iconTemplate, err;
      this.key = key = key_;
      scope = cc.scopes[scopeName];
      data = scope[key];
      $row = $row_;
      console.info("loading data", scopeName, key, data);
      if (key in cc.roles) {
        uid = 0;
        $cp.addClass('p0ne-ccp-nobadge');
        if (imageMode === 'badge') {
          $cp.find('.p0ne-ccp-tab-icon').addClass('p0ne-ccp-tab-selected').siblings().removeClass('p0ne-ccp-tab-selected');
        }
      } else {
        uid = key;
        $cp.removeClass('p0ne-ccp-nobadge');
      }
      delete scope[key];
      try {
        if (!uid) {
          styleDefault = customColors.getRoleStyle(key, true);
        } else {
          styleDefault = customColors.getUserStyle(key, true);
          badgeTemplate = function(){};
          if (uid) {
            switch (typeof styleDefault.badge) {
            case 'string':
              imageCustomMode.badge = 'default';
              styleDefault.badge = getIcon("bdg bdg-" + styleDefault.badge + " " + (ref$ = styleDefault.badge)[ref$.length - 1], true);
              styleDefault.badge.w = styleDefault.badge.h = 30;
              break;
            case 'object':
              imageCustomMode.badge = 'default';
              styleDefault.badge = styleDefault.badge;
              break;
            default:
              imageCustomMode.badge = 'none';
              styleDefault.badge = {
                w: 30,
                h: 30
              };
            }
          }
        }
        console.log("styleDefault", styleDefault);
        if (styleDefault.color != null) {
          styleDefault.color = styleDefault.color.substr(1);
        }
        iconTemplate = function(){};
        switch (typeof styleDefault.icon) {
        case 'string':
          imageCustomMode.icon = 'default';
          styleDefault.icon = getIcon(styleDefault.icon, true);
          break;
        case 'object':
          imageCustomMode.icon = 'default';
          if (styleDefault.icon.url === 'default') {
            styleDefault.icon.url = defaultIconURL;
          }
          break;
        default:
          imageCustomMode.icon = 'none';
          styleDefault.icon = {
            url: defaultIconURL,
            x: 105,
            y: 350
          };
        }
      } catch (e$) {
        err = e$;
        console.error("failed to create icon or badge template", err.messageAndStack);
        scope[key] = data;
        return;
      }
      scope[key] = data;
      if (data.color) {
        nameCustomMode = 'custom';
        $hex.val(currentColor = data.color.substr(1));
      } else {
        nameCustomMode = 'default';
        $hex.val(currentColor = styleDefault.color);
      }
      customColor = currentColor;
      font = data.font || {
        b: true,
        i: false,
        u: false
      };
      if (font.b !== false) {
        $font.b.removeClass('p0ne-ccp-btn-selected');
      } else {
        $font.b.addClass('p0ne-ccp-btn-selected');
      }
      if (font.i) {
        $font.i.addClass('p0ne-ccp-btn-selected');
      } else {
        $font.i.removeClass('p0ne-ccp-btn-selected');
      }
      if (font.u) {
        $font.u.addClass('p0ne-ccp-btn-selected');
      } else {
        $font.u.removeClass('p0ne-ccp-btn-selected');
      }
      font = clone$(font);
      console.log("typeof data.icon", typeof data.icon);
      switch (typeof data.icon) {
      case 'boolean':
        imageCustomMode.icon = 'none';
        // fallthrough
      case 'undefined':
        import$(iconTemplate.prototype, styleDefault.icon);
        break;
      case 'string':
        imageCustomMode.icon = 'custom';
        import$(iconTemplate.prototype, getIcon(data.icon, true));
        break;
      case 'object':
        imageCustomMode.icon = 'custom';
        import$(iconTemplate.prototype, data.icon);
      }
      iconTemplate.prototype.w = iconTemplate.prototype.h = styleDefault.icon.w = styleDefault.icon.h = 15;
      icon = customImage.icon = new iconTemplate;
      if (imageCustomMode.icon !== 'custom') {
        icon = styleDefault.icon;
      }
      if (uid) {
        console.log("typeof data.badge", typeof data.badge);
        switch (typeof data.badge) {
        case 'boolean':
          imageCustomMode.badge = 'custom';
          // fallthrough
        case 'undefined':
          import$(badgeTemplate.prototype, styleDefault.badge);
          /*console.log "[customColors] no badge specified, loading user data", data.uid, data.name, d
          getUserData data.uid, (d) ->
              console.log "[customColors] loaded user data", data.uid, data.name, d
              badgeTemplate:: = getIcon("bdg bdg-#{d.badge} #{d.badge[d.badge.length - 1]}", true)
              styleDefault.badge = true
              badgeTemplate::w = badgeTemplate::h = 30px*/
          break;
        case 'string':
          imageCustomMode.badge = 'custom';
          import$(badgeTemplate.prototype, getIcon("bdg bdg-" + data.badge + " " + (ref$ = data.badge)[ref$.length - 1], true));
          badgeTemplate.prototype.w = badgeTemplate.prototype.h = 30;
          break;
        case 'object':
          imageCustomMode.badge = 'custom';
          import$(badgeTemplate.prototype, data.badge);
        }
        badge = customImage.badge = new badgeTemplate;
        if (imageCustomMode.badge !== 'custom') {
          badge = styleDefault.badge;
        }
      }
      if ($cp.find('.p0ne-ccp-tab-icon').hasClass('p0ne-ccp-tab-selected')) {
        setImageMode('icon');
      } else if ($cp.find('.p0ne-ccp-tab-badge').hasClass('p0ne-ccp-tab-selected')) {
        setImageMode('badge');
      }
      console.log("imageCustomMode", imageCustomMode.icon, imageCustomMode.badge);
      console.info("==>", test());
      $nameCustomToggles.removeClass('selected').filter("[data-mode=" + nameCustomMode + "]").addClass('selected');
      inputHex();
      $currentColor.css({
        background: "#" + getHex()
      });
      $snapToGrid.attr('checked', false).click();
      $cp.show();
      sleep(200, bind$(cc, 'updateCSS'));
    };
    function rgbToHsv(rgb){
      var hsv, min, ref$, ref1$, ref2$, ref3$, max, delta;
      hsv = {
        h: 0,
        s: 0,
        v: 0
      };
      min = (ref$ = (ref2$ = rgb.r) < (ref3$ = rgb.g) ? ref2$ : ref3$) < (ref1$ = rgb.b) ? ref$ : ref1$;
      max = (ref$ = (ref2$ = rgb.r) > (ref3$ = rgb.g) ? ref2$ : ref3$) > (ref1$ = rgb.b) ? ref$ : ref1$;
      delta = max - min;
      hsv.v = max;
      hsv.s = max !== 0 ? 255 * delta / max : 0;
      if (hsv.s !== 0) {
        if (rgb.r === max) {
          hsv.h = (rgb.g - rgb.b) / delta;
        } else if (rgb.g === max) {
          hsv.h = 2 + (rgb.b - rgb.r) / delta;
        } else {
          hsv.h = 4 + (rgb.r - rgb.g) / delta;
        }
      } else {
        hsv.h = -1;
      }
      hsv.h = ~~(hsv.h * 60);
      if (hsv.h < 0) {
        hsv.h += 360;
      }
      hsv.s = ~~(hsv.s * 100 / 255);
      hsv.v = ~~(hsv.v * 100 / 255);
      return hsv;
    }
    /*
    very boredom, such fancy code, wow
    function rgbToHsvDoge(rgb) {
        var hsv, min, max, delta
        hsv = {h: 0- -0, s: 0*0+~~-0-~~+0*0, v: 0+ +0}
        min = (min = rgb.r < rgb.g ? rgb.r : rgb.g) < rgb.b ? min : rgb.b
        max = (max = rgb.r > rgb.g ? rgb.r : rgb.g) > rgb.b ? max : rgb.b
        delta = max - min
        hsv.v = max
        hsv.s = max != 1- - -1 ? - -~-(2<<9>>2) * delta / max : 1+ - +1
        if (0-~~-0 == hsv.s == 0<0>0) {
            if (rgb.r == max)
                hsv.h = ~-2 - -     (rgb.g -~~- - -~~- rgb.b) / delta - ~-2
            else if (rgb.g == max)
                hsv.h = ~-4 - - (rgb.b - -~~- - - - -~~- - rgb.r) / delta - ~-~-3
            else
                hsv.h = ~-5 - -     (rgb.r -~~- - -~~- rgb.g) / delta - ~-1
        } else {
            hsv.h = 0 +-~~-~~-+1+-~~-~~-+ 0
        }
        hsv.h *= 0 +-~~-+ 60 +-~~-+ 0
        if (hsv.h < 0+~~+0)
            hsv.h += (3<<10>>3) - (3<<6>>3)
        hsv.s *= (0 -~100 + + ~ + + 001-~ 0) / - -~-(4<<10>>4)
        hsv.v *= (0 -~100 - - ~ - - 001-~ 0) / - -~-(8>>3<<8)
        return hsv
    }
     */
    function hsvToRgb(hsv){
      var rgb, h, s, v, t1, t2, t3;
      rgb = {};
      h = hsv.h;
      s = hsv.s * 255 / 100;
      v = hsv.v * 255 / 100;
      if (s === 0) {
        rgb.r = rgb.g = rgb.b = v;
      } else {
        t1 = v;
        t2 = (255 - s) * v / 255;
        t3 = (t1 - t2) * (h % 60) / 60;
        if (h === 360) {
          h = 0;
        }
        if (h < 60) {
          rgb.r = ~~t1;
          rgb.b = ~~t2;
          rgb.g = ~~(t2 + t3);
        } else if (h < 120) {
          rgb.g = ~~t1;
          rgb.b = ~~t2;
          rgb.r = ~~(t1 - t3);
        } else if (h < 180) {
          rgb.g = ~~t1;
          rgb.r = ~~t2;
          rgb.b = ~~(t2 + t3);
        } else if (h < 240) {
          rgb.b = ~~t1;
          rgb.r = ~~t2;
          rgb.g = ~~(t1 - t3);
        } else if (h < 300) {
          rgb.b = ~~t1;
          rgb.g = ~~t2;
          rgb.r = ~~(t2 + t3);
        } else if (h < 360) {
          rgb.r = ~~t1;
          rgb.g = ~~t2;
          rgb.b = ~~(t1 - t3);
        } else {
          rgb.r = 0;
          rgb.g = 0;
          rgb.b = 0;
        }
      }
      return rgb;
    }
    updateCSS = function(){
      clearTimeout(updateCSSTimeout);
      return updateCSSTimeout = sleep(200, function(){
        var badge_, style;
        if (uid) {
          badge_ = badge[imageCustomMode.badge] || badge;
          if (!('srcW' in badge_)) {
            badge_ = void 8;
          }
        }
        style = cc[uid ? 'calcCSSUser' : 'calcCSSRole'](key, {
          color: "#" + getHex(),
          font: font,
          icon: icon[imageCustomMode.icon] || icon,
          badge: badge_
        });
        return $css.text(style);
      });
    };
    this.close = function(){
      $css.text("");
      $cp.hide();
    };
    this.save = function(){
      var style, hex, err;
      if (key) {
        try {
          style = scope[key];
          hex = "#" + getHex();
          console.info("[save]", key, hex, font, icon, badge);
          if (hex !== styleDefault.color) {
            style.color = hex;
          } else {
            delete style.color;
          }
          style.font = import$({}, font);
          switch (imageCustomMode.icon) {
          case 'custom':
            style.icon = importAll$({}, icon);
            break;
          case 'default':
            delete style.icon;
            break;
          case 'none':
            if (uid || cc.roles[key].icon) {
              style.icon = false;
            }
          }
          switch (uid && imageCustomMode.badge) {
          case 'custom':
            style.badge = importAll$({}, badge);
            break;
          case 'default':
            delete style.badge;
            break;
          case 'none':
            style.badge = false;
          }
          /*$row .html "<div class=p0ne-cc-row>
                  #{createBadge style.badge}
                  <div class=p0ne-cc-name>
                      #{createIcon style.icon}
                      #{createName style, style.name}
                      <i class='icon icon-clear-input p0ne-cc-clear-icon'></i>
                      <div class=p0ne-cc-userid>#{style.uid}</div>
                  </div>
              </div>"*/
          if (uid) {
            cc.users[uid].css = cc.calcCSSUser(uid);
          } else {
            cc.roles[key].css = cc.calcCSSRole(key);
          }
          /*if not tmpCSS
              tmpCSS := true
              $css .text ""
              css \customColors_test, $css.text!*/
        } catch (e$) {
          err = e$;
          console.error("Error while saving custom colors for " + key, err.messageAndStack);
        }
      }
    };
    out$.test = test = function(){
      return {
        styleDefault: styleDefault,
        customImage: customImage,
        $css: $css,
        image: image,
        defaultIconURL: defaultIconURL,
        currentColor: currentColor,
        customColor: customColor,
        color: color,
        colorHSV: colorHSV,
        font: font,
        nameCustomMode: nameCustomMode,
        icon: icon,
        badge: badge,
        scale: scale,
        imageMode: imageMode,
        imageCustomMode: imageCustomMode,
        imagePicker: imagePicker,
        imageEl: imageEl,
        scope: scope,
        key: key,
        uid: uid,
        snapToGrid: snapToGrid
      };
    };
    out$.loadData = loadData;
    $el.find('.p0ne-cc-row.selected').click();
  },
  createIcon: function(icon){
    return typeof icon === 'string' ? "<i class='icon " + icon + "'></i>" : "<i class='icon p0ne-icon-placeholder'></i>";
  },
  createBadge: function(badge){
    return typeof badge === 'string' ? "<div class=badge-box><i class='bdg bdg-" + badge + " " + badge[badge.length - 1] + "'></i></div>" : "<div class=badge-box></div>";
  },
  createUser: function(uid, user, currTimestamp){
    var icon, that, rank, username, l, i$, ref$, len$, role, ref1$, id, insertBeforeUID, insertBeforeName, $inserBeforeEl;
    if (that = user || (user = getUser(uid))) {
      rank = getRank(that);
      username = that.username;
      this.cc._settings.users[uid] = {
        username: that.username,
        gRole: that.gRole,
        sub: that.sub,
        friend: that.friend,
        defaultBadge: that.badge
      };
      this.cc._settings.users[uid].roles = [];
      this.cc.room.userRole[uid] = that.role;
      l = 0;
      for (i$ = 0, len$ = (ref$ = this.cc._settings.rolesOrder).length; i$ < len$; ++i$) {
        role = ref$[i$];
        if (this.cc.roles[role].test(that)) {
          if (!this.cc.roles[role].perRoom) {
            this.cc._settings.users[uid].roles[l++] = role;
          }
          if (this.cc.roles[role].icon && icon == null) {
            icon = this.cc.roles[role].icon;
          }
        }
      }
    } else if (that = user = this.cc._settings.users[uid]) {
      username = that.username;
      if (this.cc._settings.users[uid].gRole) {
        rank = getRank(this.cc._settings.users[uid]);
      } else if (this.cc.room.userRole[uid]) {
        rank = getRank(this.cc.room.userRole[uid]);
      } else {
        rank = "";
      }
      icon = (ref$ = this.cc.roles[rank]) != null ? ref$.icon : void 8;
    } else {
      throw new TypeError("createUser: User " + uid + " is not found, and no data was passed");
    }
    (ref1$ = this.cc.users)[uid] || (ref1$[uid] = {});
    this.cc.users[uid].css = this.cc.calcCSSUser(uid);
    this.cc._settings.users[uid].lastUsed = currTimestamp || Date.now();
    if (user.sub) {
      rank += " subscriber";
    }
    if (user.friend) {
      rank += " friend";
    }
    console.log("[customColors] >createUser", uid, username);
    for (id in this.rows) {
      insertBeforeUID = id;
      insertBeforeName = this.cc._settings.users[id].username;
      break;
    }
    if (insertBeforeUID) {
      for (id in this.rows) {
        if (insertBeforeName > (ref1$ = this.cc._settings.users[id].username) && ref1$ > username) {
          insertBeforeUID = id;
          insertBeforeName = this.cc._settings.users[id].username;
        }
      }
    }
    $inserBeforeEl = insertBeforeUID && this.cc._settings.users[insertBeforeUID].username < username
      ? this.rows[insertBeforeUID]
      : this.$add;
    console.log("[customColors] >createUser", uid, rank, icon, insertBeforeUID, $inserBeforeEl);
    return this.rows[uid] = $("<div class='p0ne-cc-row p0ne-uid-" + uid + "' data-scope=globalCustomUser data-key=" + uid + ">" + this.createBadge(this.cc._settings.users[uid].defaultBadge) + "<div class='p0ne-cc-name p0ne-name " + rank + "'>" + this.createIcon(icon) + "<span class=name>" + username + "</span><i class='icon icon-clear-input p0ne-cc-clear-icon'></i><div class=p0ne-cc-userid>" + uid + "</div></div></div>").insertBefore($inserBeforeEl);
  },
  disable: function(){
    var ref$, ref1$, ref2$;
    if ((ref$ = this.cc) != null) {
      if ((ref1$ = ref$._$settingsPanel) != null) {
        if ((ref2$ = ref1$.wrapper) != null) {
          ref2$.html("").off();
        }
      }
    }
  }
});
/*# sample badge spritesets
http://png-2.findicons.com/files/icons/1187/pickin_time/32/eggplant.png
https://a.thumbs.redditmedia.com/H-RxCNGKM9YqzbW-5SVWcEn7Fvjy4rlo9cAZXVuv718.png
https://fimplug.net/theme/images/badges.png
*/
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) {
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}
