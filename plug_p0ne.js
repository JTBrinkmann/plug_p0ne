// Generated by LiveScript 1.2.0
/*@author jtbrinkmann aka. Brinkie Pie */
/*@license https://creativecommons.org/licenses/by-nc/4.0/ */
/*####################################
#            AUXILIARIES             #
####################################*/
var ref$;
window.p0ne = {
  version: '0.8.6',
  host: 'https://dl.dropboxusercontent.com/u/4217628/plug_p0ne',
  has_$context: false,
  started: new Date
};
(function(d){
  d.call(Object.prototype, 'define', d);
}.call(this, function(property, fn){
  if (this[property] !== fn) {
    return Object.defineProperty(this, property, {
      enumerable: false,
      writable: true,
      configurable: true,
      value: fn
    });
  }
}));
Array.prototype.define('remove', function(i){
  return this.splice(i, 1);
});
Array.prototype.define('random', function(){
  return this[~~(Math.random() * this.length)];
});
importAll$(window, {
  repeat: function(timeout, fn){
    return setInterval(function(){
      if (!disabled) {
        return fn.apply(this, arguments);
      }
    }, timeout);
  },
  sleep: function(timeout, fn){
    return setTimeout(fn, timeout);
  },
  generateID: function(){
    return (~~(Math.random() * 0xFFFFFF)).toString(16).toUpperCase();
  },
  getUserByName: function(name){
    var i$, ref$, len$, user;
    for (i$ = 0, len$ = (ref$ = API.getUsers()).length; i$ < len$; ++i$) {
      user = ref$[i$];
      if (user.username === name) {
        return user;
      }
    }
    for (i$ = 0, len$ = (ref$ = stats.users || []).length; i$ < len$; ++i$) {
      user = ref$[i$];
      if (user.username === name) {
        return user;
      }
    }
  },
  getUserByID: function(id){
    var i$, ref$, len$, user;
    for (i$ = 0, len$ = (ref$ = API.getUsers()).length; i$ < len$; ++i$) {
      user = ref$[i$];
      if (user.id === id) {
        return user;
      }
    }
    for (i$ = 0, len$ = (ref$ = stats.users || []).length; i$ < len$; ++i$) {
      user = ref$[i$];
      if (user.id === id) {
        return user;
      }
    }
  },
  logger: function(loggerName, fn){
    return function(){
      console.log("[" + loggerName + "]", arguments);
      return typeof fn === 'function' ? fn.apply(this, arguments) : void 8;
    };
  },
  replace: function(context, attribute, cb){
    var key$;
    context[key$ = attribute + "_"] || (context[key$] = context[attribute]);
    return context[attribute] = cb(context[attribute + "_"]);
  },
  loadScript: function(loadedEvent, data, file, callback){
    var d;
    d = $.Deferred();
    if (callback) {
      d.then(callback);
    }
    if (data) {
      d.resolve();
    } else {
      $.getScript(p0ne.host + "/" + file);
      $(window).one(loadedEvent, d.resolve);
    }
    return d.promise();
  },
  requireHelper: function(a){
    var name, id, test, onfail, fallback, module, ref$;
    name = a.name, id = a.id, test = a.test, onfail = a.onfail, fallback = a.fallback;
    if (typeof a === 'function') {
      test = a;
    }
    if (id) {
      module = require.s.contexts._.defined[id];
    }
    if (module && test(module)) {
      module.id || (module.id = id);
      return module;
    } else {
      for (id in ref$ = require.s.contexts._.defined) {
        module = ref$[id];
        if (module && test(module, id)) {
          module.id == null && (module.id = id);
          console.warn("[requireHelper] module '" + name + "' updated to ID '" + id + "'");
          if (name) {
            window[name] = module;
          }
          return module;
        }
      }
      if (typeof onfail === 'function') {
        onfail();
      }
      if (name) {
        window[name] = fallback;
      }
      return fallback;
    }
  },
  addListener: function(data, b){
    var name, setup, update, callback, disable, ref$, disabled, wrapper;
    name = data.name, setup = data.setup, update = data.update, callback = data.callback, disable = data.disable;
    if (typeof data === 'string') {
      b.name = data;
      ref$ = data = b, name = ref$.name, setup = ref$.setup, update = ref$.update, callback = ref$.callback, disable = ref$.disable;
    }
    disabled = false;
    name || (name = "unnamed_" + generateID());
    if (!window[name]) {
      wrapper = function(){
        if (!window.disable && !window.disable && !disabled) {
          return window[name].apply(this, arguments);
        }
      };
      if (typeof setup === 'function') {
        setup(wrapper, update);
      }
      console.warn("[" + name + "] initialized");
    } else if (update || callback && window[name] !== callback) {
      if (typeof update === 'function') {
        update(window[name]);
      }
      console.warn("[" + name + "] updated");
    } else {
      return;
    }
    if (callback) {
      window[name] = callback;
      return (ref$ = window[name]) != null ? ref$.disable = function(){
        if (disabled) {
          return console.warn("[" + name + "] already disabled");
        }
        disabled = true;
        if (typeof disable === 'function') {
          disable(wrapper);
        }
        return console.warn("[" + name + "] disabled");
      } : void 8;
    } else {
      return window[name] = true;
    }
  },
  replace_$Listener: function(type, callback){
    var evts, i$, len$, e, ref$, disabled;
    if (!_$context) {
      console.error("[ERROR] unable to replace listener in _$context._events['" + type + "'] (no _$context)");
      return false;
    }
    if (!(evts = _$context._events[type])) {
      console.error("[ERROR] unable to replace listener in _$context._events['" + type + "'] (no such event)");
      return false;
    }
    for (i$ = 0, len$ = evts.length; i$ < len$; ++i$) {
      e = evts[i$];
      if ((ref$ = e.context) != null && ref$.cid) {
        e.callback_ || (e.callback_ = e.callback);
        e.callback = callback;
        disabled = false;
        console.warn("[" + name + "] replaced eventlistener", e);
        return {
          type: type,
          listener: e,
          callback: callback,
          original: e.callback_,
          disable: fn$,
          enable: fn1$,
          update: fn2$
        };
      }
    }
    console.error("[ERROR] unable to replace listener in _$context._events['" + type + "'] (no vanilla callback found)");
    return false;
    function fn$(){
      var disabled;
      if (disabled) {
        return console.warn("[" + name + "] already disabled");
      }
      e.callback = e.callback_;
      return disabled = true;
    }
    function fn1$(){
      var disabled;
      if (!disabled) {
        return console.warn("[" + name + "] already enabled");
      }
      e.callback = callback;
      return disabled = false;
    }
    function fn2$(fn){
      callback = fn;
      if (!disabled) {
        return e.callback = fn;
      }
    }
  }
  /* callback gets called with the arguments cb(errorCode, response, event) */,
  ajax: function(command, body, cb){
    var cb_;
    cb_ = function(error, body){
      if (error) {
        console.error("[" + command + "]", error, body);
      } else if (body.length === 0) {
        console.warn("[" + command + "]", body);
      } else {
        console.log("[" + command + "]", body);
      }
      return typeof cb === 'function' ? cb.apply(this, arguments) : void 8;
    };
    return $.ajax({
      type: 'POST',
      url: "http://plug.dj/_/" + command,
      contentType: 'application/json',
      data: JSON.stringify({
        body: body
      }),
      success: function(arg$){
        var status, body;
        status = arg$.status, body = arg$.body;
        return cb_(status, body);
      },
      error: function(err){
        return cb_(-1, err);
      }
    });
  },
  humanList: function(arr){
    arr = importAll$([], arr);
    if (arr.length > 1) {
      arr[arr.length - 2] += " and\xa0" + elements.pop();
    }
    return arr.join(", ");
  },
  getTime: function(t){
    t == null && (t = new Date);
    return t.toISOString().replace(/.+?T|\..+/g, '');
  },
  getISOTime: function(){
    return new Date().toISOString().replace(/T|\..+/g, " ");
  },
  humanTime: function(diff){
    var b, c;
    if (diff < 0) {
      return "-" + humanTime(-diff);
    }
    b = [60, 60, 24, 360.25];
    c = 0;
    diff /= 1000;
    while (diff > 2 * b[c]) {
      diff /= b[c++];
    }
    return ~~diff + " " + 'seconds/minutes/hours/days'.split('/')[c];
  },
  ago: function(d){
    return humanTime(Date.now() - d) + " ago";
  },
  css: (function($style, styles){
    return function(name, styles){
      var res, n;
      styles[name] = styles;
      res = "";
      for (n in styles) {
        styles = styles[n];
        res += "/* " + n + " */\n" + styles + "\n\n";
      }
      return $style.html(res);
    };
  }.call(this, $('<style>').appendTo('body'), {})),
  lssize: function(sizeWhenDecompressed){
    var size, i$, ref$, x;
    size = 0;
    for (i$ in ref$ = localStorage) {
      x = ref$[i$];
      if (sizeWhenDecompressed) {
        x = decompress(x);
      }
      size += x.length / 524288;
    }
    return size;
  },
  formatMB: function(it){
    return it.toFixed(2) + "MB";
  },
  getArgs: function(){
    var f, i, stack, res, i$, ref$, len$, o, a;
    f = arguments.callee;
    i = 0;
    stack = [];
    res = [];
    while (-1 === stack.indexOf(f = f.caller) && f) {
      stack[i] = f;
      res[i] = [f];
      for (i$ = 0, len$ = (ref$ = f.arguments).length; i$ < len$; ++i$) {
        o = i$;
        a = ref$[i$];
        res[i][1 + o] = a;
      }
      i++;
    }
    return res;
  },
  disabled: false,
  user: API.getUser(),
  roomname: location.pathname.substr(1, location.pathname.length - 2),
  $popup: $('#dialog-container'),
  stats: localStorage.stats && JSON.parse(localStorage.stats) || {
    users: []
  },
  userID: API.getUser().id,
  IDs: {
    Sgt_Chrysalis: 4131382,
    The_Sensational_Stallion: 4103672,
    Sweetie_Mash: 3919787,
    BrinkieBot: 4067112,
    Brinkie: 3966366,
    BrinkiePie: 3966366
  }
});
/*####################################
#          REQUIRE MODULES           #
####################################*/
window.has_$context = true;
window._$context = requireHelper({
  name: '_$context',
  id: 'de369/dcf72/c5fc5',
  test: function(it){
    var ref$;
    return (ref$ = it._events) != null ? ref$['chat:receive'] : void 8;
  },
  fallback: {
    _events: {}
  },
  onfail: function(){
    console.error("[p0ne require] couldn't load '_$context'. Some modules might not work");
    return window.has_$context = false;
  }
});
window._$context.onEarly = function(type, callback, context){
  var ref$;
  ((ref$ = this._events)[type] || (ref$[type] = [])).unshift({
    callback: callback,
    context: context,
    ctx: context || this
  });
  return this;
};
if ((ref$ = window.app) != null && ref$.nodeType) {
  window.app = null;
}
(function(cb){
  var waitForApp;
  if (window.app) {
    return cb();
  }
  window.App = requireHelper({
    name: 'App',
    id: 'de369/d86c0/de369/f9f73',
    test: function(it){
      var ref$;
      return ((ref$ = it.prototype) != null ? ref$.el : void 8) === 'body';
    },
    fallback: {
      prototype: {}
    }
  });
  App.prototype.animate = (function(animate_){
    return function(){
      window.app = p0ne.app = this;
      console.log("[p0ne] got `app`");
      App.prototype.animate = animate_;
      return animate_.apply(this, arguments);
    };
  }.call(this, App.prototype.animate));
  return (waitForApp = function(){
    if (window.app) {
      return cb();
    }
    return sleep(50, waitForApp);
  })();
})(function(){
  var i$, ref$, len$, e, ref1$, cm, p0ne, d, dayISO, timezoneISO, chatWidth, roles, host, _FLAG_NSFW, _FLAG_REDIRECT, emote_regexp, sanitize_emote, lookup_core_emote, convert_emote_element, icon, mediaURL, wrap;
  window.room = requireHelper({
    name: 'room',
    id: 'ce221/bbc3c/ecebe',
    test: function(m){
      var ref$;
      return 'staffAvatar' in ((ref$ = m.constructor) != null ? ref$.prototype.defaults : void 8);
    }
  });
  window.compressor_ = requireHelper({
    name: 'compressor',
    id: 'e1722/cbf30/b8829',
    test: function(it){
      return it.compress;
    },
    onfail: function(){
      console.error("[p0ne require] couldn't load 'compress'. The restoreChatScript may only run in restricted mode.");
      return console.warn("[rCS] occupied LocalStorage space: " + formatMB(lssize()) + " / 10MB");
    }
  });
  if (compressor_) {
    window.compress = function(data){
      return "1|" + compressor_.compress(data);
    };
  } else {
    window.compress = function(data){
      return "0|" + data;
    };
  }
  window.decompress = function(data){
    if (data[1] === "|") {
      if (data[0] === "1") {
        if (compressor_) {
          return compressor_.decompress(data.substr(2));
        } else {
          console.warn("[p0ne compress] can't decompress, because plug.dj Compress module is missing.");
          return false;
        }
      } else if (data[0] === "0") {
        return data.substr(2);
      }
    } else {
      return data;
    }
  };
  window.Curate = requireHelper({
    name: 'Curate',
    id: 'de369/d2d18/b87de/b006c',
    test: function(m){
      return m.prototype && (m.prototype.execute + "").indexOf("/media/insert") !== -1;
    }
  });
  window.playlists = requireHelper({
    name: 'playlists',
    id: 'de369/a4447/eb1cd',
    test: function(it){
      return it.activeMedia;
    }
  });
  window.users = requireHelper({
    name: 'users',
    id: 'de369/a4447/faa37',
    test: function(it){
      var ref$, ref1$;
      return ((ref$ = it.models) != null ? (ref1$ = ref$[0]) != null ? ref1$.attributes.avatarID : void 8 : void 8) && !('isTheUserPlaying' in it) && !('lastFilter' in it);
    }
  });
  window.auxiliaries = requireHelper({
    name: 'auxiliaries',
    id: 'de369/a7486/bc55d',
    test: function(it){
      return it.deserializeMedia;
    }
  });
  if (!(window.chat = app.room.chat)) {
    for (i$ = 0, len$ = (ref$ = (typeof _$context != 'undefined' && _$context !== null ? _$context._events['chat:receive'] : void 8) || []).length; i$ < len$; ++i$) {
      e = ref$[i$];
      if ((ref1$ = e.context) != null && ref1$.cid) {
        window.chat = e.context;
        break;
      }
    }
  }
  if (chat) {
    importAll$(window, {
      $cm: function(){
        if (window.saveChat) {
          return saveChat.$cm;
        } else {
          return chat.$chatMessages;
        }
      },
      playChatSound: function(isMention){
        if (isMention) {
          return this.playSound('mention');
        } else if ($('.icon-chat-sound-on').length > 0) {
          return this.playSound('chat');
        }
      }
    });
  } else {
    cm = $('#chat-messages');
    importAll$(window, {
      $cm: function(){
        return cm;
      },
      playChatSound: function(isMention){}
    });
  }
  importAll$(window, {
    appendChat: function(div, isMention, wasAtBottom){
      wasAtBottom == null && (wasAtBottom = chatIsAtBottom());
      if (window.saveChat) {
        window.saveChat.$cChunk.append(div);
      } else {
        $cm().append(div);
      }
      if (wasAtBottom) {
        chatScrollDown();
      }
      return playChatSound(isMention);
    },
    chatIsAtBottom: function(){
      var cm;
      cm = $cm();
      return cm.scrollTop() > cm[0].scrollHeight - cm.height() - 20;
    },
    chatScrollDown: function(){
      var x$;
      x$ = $cm();
      x$.scrollTop(x$[0].scrollHeight);
      return x$;
    }
  });
  /*####################################
  #           extend jQuery            #
  ####################################*/
  replace(jQuery, 'Deferred', function(Deferred_){
    return function(){
      var d, res, timeStarted;
      d = Date.now();
      res = Deferred_.apply(this, arguments);
      timeStarted = res.timeStarted = d;
      res.timeout = timeout;
      replace(res, 'promise', function(promise_){
        return function(){
          var res;
          res = promise_.apply(this, arguments);
          res.timeout = timeout;
          res.timeStarted = timeStarted;
          return res;
        };
      });
      return res;
      function timeout(time, callback){
        var now, this$;
        now = Date.now();
        if (this.state() !== 'pending') {
          console.log("[timeout] already " + this.state());
          return;
        }
        if (timeStarted + time <= now) {
          console.log("[timeout] running callback now (Deferred started " + ago(timeStarted) + ")");
          return callback.call(this, this);
        } else {
          console.log("[timeout] running callback in " + humanTime(timeStarted + time - now) + " / " + humanTime(time) + " (Deferred started " + ago(timeStarted) + ")");
          this$ = this;
          return setTimeout(function(){
            if (this.state() === 'pending') {
              return callback.call(this$, this$);
            }
          }, timeStarted + time - now);
        }
      }
      return timeout;
    };
  });
  /*####################################
  #     Listener for other Scripts     #
  ####################################*/
  (function(d){
    var plugCubed;
    if (window.plugCubed) {
      d.resolve();
    } else {
      plugCubed = {
        close: d.resolve
      };
    }
    window.plugCubedLoaded = d.promise();
  }.call(this, $.Deferred()));
  (function(d){
    var ppStop;
    if (window.ppSaved) {
      d.resolve();
    } else {
      ppStop = d.resolve;
    }
    window.plugplugLoaded = d.promise();
  }.call(this, $.Deferred()));
  /*@author jtbrinkmann aka. Brinkie Pie */
  /*@license https://creativecommons.org/licenses/by-nc/4.0/ */
  module('statusCommand', {
    timeout: false,
    callback: {
      target: API,
      event: API.CHAT,
      bound: true,
      callback: function(data){
        var msg;
        if (this.timeout) {
          return;
        }
        if (data.message.indexOf("@" + user.username) !== -1 && data.message.indexOf("!status") !== -1) {
          this.timeout = true;
          msg = "Running plug_p0ne v" + p0ne.version;
          if (window.p0ne_chat) {
            msg += " (incl. chat script)";
          }
          if (requirejs.defined('plugCubed/Version')) {
            msg += " and plugÂ³ v" + require('plugCubed/Version');
          }
          if (window.ppSaved) {
            msg += " and plugplug " + getVersionShort();
          }
          msg += ". Started " + ago(p0ne.started);
          console.log("[AUTORESPOND] '" + msg + " @" + data.un + "'");
          API.sendChat(msg + " @" + data.un);
          return sleep(30 * 60000, function(){
            this.timeout = false;
            return console.info("[autoPostFaces] timeout reset");
          });
        }
      }
    }
  });
  module('_$contextUpdateEvent', {
    require: ['_$context'],
    setup: function(arg$){
      var replace;
      replace = arg$.replace;
      replace(_$context, 'on', 'cb');
      return replace(_$context, 'off', 'cb');
    },
    cb: function(fn_){
      return function(type, cb, context){
        fn_.apply(this, arguments);
        return _$context.trigger('context:update', type, cb, context);
      };
    }
  });
  /*####################################
  #                FIXES               #
  ####################################*/
  module('simpleFixes', {
    setup: function(arg$){
      var replace;
      replace = arg$.replace;
      plugCubedLoaded.then(function(){
        return replace(require("plugCubed/Socket").__proto__, 'connect', function(){});
      });
      requireHelper({
        test: function(it){
          return it.ack;
        }
      }).ack = function(){};
      $('.social-menu').hide();
      return $('#chat-input-field').prop('tabIndex', 1);
    },
    disable: function(){
      return $('.social-menu').show();
    }
  });
  module('soundCloudThumbnailFix', {
    require: ['auxiliaries'],
    setup: function(){
      return auxiliaries.deserializeMedia = function(e){
        e.author = this.h2t(e.author);
        e.title = this.h2t(e.title);
        if (e.image) {
          e.image = e.image.replace(/^https?:\/\//, '//');
        }
      };
    }
  });
  /*####################################
  #             /COMMANDS              #
  ####################################*/
  module('chatCommands', {
    callback: {
      target: API,
      event: API.CHATCOMMAND,
      callback: function(msg){
        var c, substr;
        if (c = this.commands[msg.split(" ")[0].substr(1)]) {
          substr = msg.substr(c.length + 2);
          if (typeof c === 'string') {
            c = this.commands[c];
          }
          return false === c(substr, msg);
        }
      }
    },
    commands: {
      chat: function(message){
        if (window._$context) {
          return _$context.trigger('chat:send', message);
        }
      }
    }
  });
  /*####################################
  #           FIX POPUP BUG            #
  ####################################*/
  /*
  #ToDo
  module \fixPopup, callback:
      target: socket
      event: \connect
      callback: ->
          if $popup.css(\display) != \none
              console.log "===================\nfixed popup\n==================="
              $popup .hide!
          else
              sleep 200ms, ->
                  console.log "===================\nlate fixed popup\n==================="
                  $popup .hide!
  */
  /*####################################
  #            GRAB / CURATE           #
  ####################################*/
  if (window.grab.nodeType) {
    window.grab = null;
  }
  module('grab', {
    optional: ['Curate', 'playlists'],
    module: function(playlist){
      var m, id, i$, ref$, len$, pl, t;
      m = API.getMedia();
      if (m) {
        console.log("[Curate] add '" + m.author + " - " + m.title + "' to playlist: " + playlist);
      } else {
        return console.error("[Curate] no DJ is playing!");
      }
      if (Curate) {
        if (typeof playlist === 'string') {
          id = playlist;
          playlist = false;
          if (playlists) {
            for (i$ = 0, len$ = (ref$ = playlists).length; i$ < len$; ++i$) {
              pl = ref$[i$];
              if (pl.id === id) {
                playlist = pl;
                break;
              }
            }
          } else {
            console.warn("[grab] warning: using fallback, because the list of playlists couldn't be loaded");
          }
        }
        if (playlist) {
          t = new Curate(4759858, [m], false);
          t.on('success', function(){
            return console.log("[grab] success", arguments);
          }).on('error', function(){
            return console.log("[grab] error", arguments);
          });
          return true;
        }
      }
      if (typeof playlist !== 'string') {
        console.error("[grab] error: can't curate to playlist by ID in fallback-mode (proper playlist module failed to load)");
      }
      $('#curate').click();
      return sleep(500, function(){
        var pls;
        pls = $('.pop-menu.curate ul span').filter(function(){
          return this.innerText === playlist;
        }).mousedown();
        if (!pls.length) {
          return console.warn("[Curate] playlist '" + playlist + "' not found", pls);
        }
      });
    }
  });
  /*####################################
  #             ZALGO FIX              #
  ####################################*/
  module('zalgoFix', {
    setup: function(){
      return css('zalgoFix', '.message {overflow: hidden;}');
    }
  });
  /*####################################
  #       TITLE FOR CURRENT SONG       #
  ####################################*/
  module('titleCurrentSong', {
    disable: function(){
      return $('#now-playing-media').prop('title', "");
    },
    callback: {
      target: API,
      event: API.ADVANCE,
      callback: function(d){
        return $('#now-playing-media').prop('title', d.media.author + " - " + d.media.author);
      }
    }
  });
  /*####################################
  #           RESTORE CHAT             #
  ####################################*/
  module('restoreChatScript', {
    require: ['compressor'],
    setup: function(arg$, rCS){
      var addListener, btn;
      addListener = arg$.addListener;
      addListener({
        target: $(window),
        event: 'beforeunload',
        callback: function(){
          return "are you sure you want to leave?";
        }
      });
      addListener({
        target: $(window),
        event: 'unload',
        callback: function(){
          return window.restoreChatScript.save();
        }
      });
      if (rCS.maxAge > Date.now() - rCS.savedChatTime) {
        return rCS.restore();
      } else if (rCS.savedChatTime) {
        console.log("[rCS] not restoring chat from " + ago(rCS.savedChatTime) + " (too old)");
        return $cm.prepend(btn = $('<button>').text("force loading previous chatlog (" + ago(rCS.savedChatTime) + ")").click(function(){
          window.restoreChatScript.restore();
          return $(this).remove();
        }));
      } else {
        console.error("[rCS] no chatlog found");
        return API.chatLog("[rCS] no chatlog found", true);
      }
    },
    module: function(){
      var lssize_, $cm, hasCompressor, savedChatTime;
      lssize_ = lssize();
      if (lssize_ > 8) {
        API.chatLog("[rCS] WARNING: the LocalStorage is nearly full. Further chatlogs might not be saved. (" + formatMB(lssize_) + " / 10MB)", true);
      }
      $cm = $('#chat-messages');
      hasCompressor = +!!compressor_;
      savedChatTime = +localStorage.getItem('plugDjChatTime');
      return {
        maxAge: 10 * 1000 * 60,
        savedChatTime: savedChatTime,
        ago: ago(new Date + {
          save: function(){
            var html;
            if (typeof btn != 'undefined' && btn !== null) {
              btn.remove();
            }
            html = (+hasCompressor) + "|" + compressor.compress($cm[0].innerHTML);
            localStorage.setItem('plugDjChatTime', Date.now());
            return localStorage.setItem("plugDjChat-" + new Date().toISOString(), html);
          }
        }),
        restore: function(){
          var html, isCompressed, x$;
          console.log("[rCS] restoring chat from " + rCS.ago);
          html = localStorage.getItem("plugDjChat-" + new Date(savedChatTime).toISOString());
          isCompressed = html[0];
          html = html.substr(2);
          console.log("[rCS]", html.substr(0, 100));
          if (isCompressed) {
            console.info("[rCS] compressed");
            if (!hasCompressor) {
              API.chatLog("[rCS] WARNING: couldn't load last chat because the it is compressed, but the compressor couldn't be loaded. Sorry =(", true);
              return;
            }
            html = compressor.decompress(html);
          } else {
            console.warn("[rCS] not compressed");
          }
          x$ = $cm;
          x$.prepend(html);
          x$.animate({
            scrollTop: x$.prop('scrollHeight', 1000)
          });
          return x$;
        }
      };
    }()
  });
  /*####################################
  #             YELLOW MOD             #
  ####################################*/
  module('yellowMod', {
    setup: function(){
      return css('yellowMod', "#chat .from-" + API.getUser().id + " .from {color: #ffdd6f !important;}");
    }
  });
  /*####################################
  #      DISABLE MESSAGE DELETE        #
  ####################################*/
  module('disableChatDelete', {
    require: ['_$context'],
    setup: function(arg$){
      var replace_$Listener;
      replace_$Listener = arg$.replace_$Listener;
      css('disableChatDelete', '.deleted {border-left: 2px solid red;}.deleted-message {display: block;text-align: right;color: red;font-family: monospace;}');
      replace_$Listener('chat:delete', function(arg$){
        var ref$, moderator, cid, wasAtBottom;
        ref$ = arg$.data, moderator = ref$.moderator, cid = ref$.cid;
        wasAtBottom = typeof isChatAtBottom === 'function' ? isChatAtBottom() : void 8;
        $(".cid-" + cid).addClass('deleted').append($('<span>').addClass('deleted-message').text("deleted by " + moderator + " at " + ((typeof getISOTime === 'function' ? getISOTime() : void 8) || new Date().toISOString())));
        if (wasAtBottom) {
          return typeof scrollChatDown === 'function' ? scrollChatDown() : void 8;
        }
      });
      return replace_$Listener('ChatFacadeEvent:clear', function(){
        var t, wasAtBottom;
        t = getISOTime() || new Date().toISOString();
        console.log("======================\n[CHAT CLEAR]\n======================");
        wasAtBottom = typeof isChatAtBottom === 'function' ? isChatAtBottom() : void 8;
        this.$chatMessages.append($('<div>').addClass("system drag-media-label").css({
          top: 0
        }).append('<span class="text">~~~~~~~~~~~~~~~~<br>CHAT GOT CLEARED<br>~~~~~~~~~~~~~~~~</span>').append($('<time>').addClass('timestamp').attr('datetime', t).text(t)));
        if (wasAtBottom) {
          return typeof scrollChatDown === 'function' ? scrollChatDown() : void 8;
        }
      });
    }
  });
  /*####################################
  #           LOG EVERYTHING           #
  ####################################*/
  module('logAllEvents', {
    require: ['_$context'],
    setup: function(arg$){
      var replace;
      replace = arg$.replace;
      return replace(_$context, 'trigger', 'trigger');
    },
    trigger: function(trigger_){
      return function(type){
        var type_, ref$;
        type_ = type;
        if (type === window.chat_send) {
          type_ = "chat:send*";
        }
        if ((ref$ = type.split(":")[0]) !== 'tooltip' && ref$ !== 'chat' && ref$ !== 'sio' && ref$ !== 'popout' && ref$ !== 'playback' && ref$ !== 'playlist' && ref$ !== 'notify' && ref$ !== 'drag' && ref$ !== 'audience' && ref$ !== 'anim' && ref$ !== 'HistorySyncEvent') {
          console.log(getTime() + " [" + type_ + "]", getArgs());
        }
        /*else if type == "chat:receive"
            data = &1
            console.log "#{getTime!} [CHAT]", "#{data.from.id}:\t", data.text, {data}*/
        return trigger_.apply(this, arguments);
      };
    }
  });
  module('logChat', {
    callback: {
      target: API,
      event: 'chat',
      callback: function(data){
        return console.log(getTime() + " [CHAT]", data.un + ":\t", data.message);
      }
    }
  });
  /*####################################
  #             DEV TOOLS              #
  ####################################*/
  module('downloadLink', {
    setup: function(){
      return this.update();
    },
    update: function(){
      return css('downloadLink', '.p0ne_downloadlink::before {content: " ";position: absolute;margin-top: -6px;margin-left: -27px;width: 30px;height: 30px;background-position: -140px -280px;background-image: url(/_/static/images/icons.26d92b9.png);}');
    },
    module: function(name, filename, data){
      var url;
      if (!data) {
        data = filename;
        filename = name;
      }
      if (typeof data !== 'string') {
        data = JSON.stringify(data);
      }
      url = URL.createObjectURL(new Blob([data], {
        type: 'text/plain'
      }));
      return (window.$cm || $('#chat-messages')).append("<div class='message p0ne_downloadlink'><i class='icon'></i><span class='text'><a href='" + url + "' download='" + filename + "'>" + name + "</a></span></div>");
    }
  });
  importAll$(window, {
    rename: function(newName){
      return ajax('user.change_name_1', [newName]);
    },
    searchEvents: function(regx){
      var k;
      if (!(regx instanceof RegExp)) {
        regx = new RegExp(regx, 'i');
      }
      return (function(){
        var results$ = [];
        for (k in typeof _$context != 'undefined' && _$context !== null ? _$context._events : void 8) {
          if (regx.test(k)) {
            results$.push(k);
          }
        }
        return results$;
      }());
    },
    listUsers: function(){
      var res, i$, ref$, len$, u;
      res = "";
      for (i$ = 0, len$ = (ref$ = API.getUsers()).length; i$ < len$; ++i$) {
        u = ref$[i$];
        res += u.id + "\t" + u.username + "\n";
      }
      return console.log(res);
    },
    listUsersByAge: function(){
      var a, i$, len$, u, results$ = [];
      a = API.getUsers().sort(function(a, b){
        a = +a.dateJoined.replace(/\D/g, '');
        b = +b.dateJoined.replace(/\D/g, '');
        return (a > b && 1) || (a === b && 0) || -1;
      });
      for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
        u = a[i$];
        results$.push(console.log(u.dateJoined.replace(/T|\..+/g, ' '), u.username));
      }
      return results$;
    },
    getUserData: function(user){
      var i$, ref$, len$, u;
      if (typeof user === 'number') {
        return $.get("/_/users/" + user).then(function(arg$){
          var data, user;
          data = arg$.data, user = data[0];
          console.log("[userdata]", user);
          if (user.level >= 5) {
            return console.log("[userdata] https://plug.dj/@/" + encodeURI(user.slug));
          }
        }).fail(function(){
          return console.warn("couldn't get slug for user with id '" + id + "'");
        });
      } else if (typeof user === 'string') {
        user = user.toLowerCase();
        for (i$ = 0, len$ = (ref$ = API.getUsers()).length; i$ < len$; ++i$) {
          u = ref$[i$];
          if (u.username.toLowerCase() === user) {
            return getUserData(u.id);
          }
        }
        console.warn("[userdata] user '" + user + "' not found");
        return null;
      }
    },
    findModule: function(test){
      var res, id, ref$, module;
      res = [];
      for (id in ref$ = require.s.contexts._.defined) {
        module = ref$[id];
        if (module) {
          if (test(module, id)) {
            module.id || (module.id = id);
            console.log("[findModule]", id, module);
            res[res.length] = module;
          }
        }
      }
      return res;
    },
    compressOldChatlogs: function(){
      var lssize_, ls, k, oldsize, newsize, lssizeNew;
      lssize_ = lssize();
      console.log("[compressOldChatlogs] before: " + formatMB(lssize_));
      ls = localStorage;
      for (k in ls) {
        if (0 === k.indexOf("plugDjChat-")) {
          oldsize = ls[k].length / 524288;
          if (ls[k][0] === "0") {
            ls[k] = (+hasCompressor) + "|" + compressor.compress(ls[k].substr(2));
            newsize = ls[k].length / 524288;
            console.log("[compressOldChatlogs]", "'" + k + "' [uncompressed] from " + formatMB(oldsize) + " to " + formatMB(newsize));
          } else if (ls[k][0] !== "1") {
            ls[k] = (+hasCompressor) + "|" + compressor.compress(ls[k]);
            newsize = ls[k].length / 524288;
            console.log("[compressOldChatlogs]", "'" + k + "' [oldformat] from " + formatMB(oldsize) + " to " + formatMB(newsize));
          } else {
            console.log("[compressOldChatlogs]", "'" + k + "' [compressed] untouched (" + formatMB(oldsize) + ")");
          }
        }
      }
      lssizeNew = lssize();
      return console.log("[compressOldChatlogs] compressed from " + formatMB(lssize_) + " to " + formatMB(lssizeNew) + " (" + (100 * lssizeNew / lssize_).toFixed(2) + "%)");
    }
  });
  module('renameUser', {
    require: ['users'],
    module: function(idOrName, newName){
      var u, i$, ref$, len$, user, id, rup;
      u = users.get(idOrName);
      if (!u) {
        idOrName = idOrName.toLowerCase();
        for (i$ = 0, len$ = (ref$ = users).length; i$ < len$; ++i$) {
          user = ref$[i$];
          if (user.attributes.username.toLowerCase() === idOrName) {
            u = user;
            break;
          }
        }
      }
      if (!u) {
        return console.error("[rename user] can't find user with ID or name '" + idOrName + "'");
      }
      u.set('username', newName);
      id = u.id;
      if (!(rup = window.p0ne.renameUserPlugin)) {
        rup = window.p0ne.renameUserPlugin = function(d){
          d.un = rup[d.fid] || d.un;
        };
        if ((ref$ = window.p0ne.chatPlugins) != null) {
          ref$[ref$.length] = rup;
        }
      }
      return rup[id] = newName;
    }
  });
  (function(){
    var k, ref$, v, results$ = [];
    window._$events = {};
    for (k in ref$ = typeof _$context != 'undefined' && _$context !== null ? _$context._events : void 8) {
      v = ref$[k];
      results$.push(window._$events[k.replace(/:/g, '_')] = v);
    }
    return results$;
  })();
  module('export_', {
    require: ['downloadLink'],
    exportRCS: function(){
      var k, ref$, v, results$ = [];
      for (k in ref$ = localStorage) {
        v = ref$[k];
        results$.push(downloadLink("plugDjChat '" + k + "'", k.replace(/plugDjChat-(.*?)T(\d+):(\d+):(\d+)\.\d+Z/, "$1 $2.$3.$4.html"), v));
      }
      return results$;
    },
    exportPlaylists: function(){
      var i$, len$, results$ = [];
      for (i$ = 0, len$ = playlists.length; i$ < len$; ++i$) {
        results$.push((fn$.call(this, playlists[i$])));
      }
      return results$;
      function fn$(pl){
        return $.get("/_/playlists/" + pl.id + "/media").then(function(data){
          return downloadLink("playlist '" + pl.name + "'", pl.name + ".txt", data);
        });
      }
    }
  });
  /*@author jtbrinkmann aka. Brinkie Pie */
  /*@license https://creativecommons.org/licenses/by-nc/4.0/ */
  p0ne = window.p0ne;
  d = new Date;
  dayISO = d.toISOString().substr(0, 10);
  timezoneISO = -d.getTimezoneOffset();
  timezoneISO = Math.floor(timezoneISO / 60) + ":" + timezoneISO % 60;
  chatWidth = 328;
  window.database = requireHelper({
    name: 'database',
    id: 'de369/f76f4/ea401\'',
    test: function(it){
      return it.settings;
    },
    fallback: {
      settings: {
        chatTS: 24
      }
    }
  });
  window.lang = requireHelper({
    name: 'lang',
    id: 'lang/Lang',
    test: function(it){
      var ref$;
      return (ref$ = it.welcome) != null ? ref$.title : void 8;
    },
    fallback: {
      chat: {
        'delete': "Delete"
      }
    }
  });
  window.Chat = requireHelper({
    name: 'Chat',
    id: 'de369/d86c0/e7368/eaad6/b2e50',
    test: function(it){
      var ref$;
      return (ref$ = it.prototype) != null ? ref$.onDeleteClick : void 8;
    },
    fallback: (ref$ = window.app) != null ? (ref1$ = ref$.room) != null ? ref1$.chat.constructor : void 8 : void 8
  });
  window.ChatHelper = requireHelper({
    name: 'ChatHelper',
    id: 'de369/ac84a/a8802',
    test: function(it){
      return it.sendChat && it !== window.API;
    }
  });
  window.Spinner = requireHelper({
    name: 'Spinner',
    id: 'de369/d86c0/bf208/e0fc2',
    test: function(it){
      var ref$;
      return ((ref$ = it.prototype) != null ? ref$.className : void 8) === 'spinner';
    }
  });
  window.imgError = function(elem){
    var x$;
    console.warn("[inline-img] converting image back to link", elem.alt, elem, elem.outerHTML);
    x$ = $(elem).parent();
    x$.text(x$.attr('href'));
    x$.addClass('p0ne_img_failed');
    return x$;
  };
  p0ne.pendingMessages || (p0ne.pendingMessages = []);
  p0ne.failedMessages || (p0ne.failedMessages = []);
  p0ne.chatPlugins || (p0ne.chatPlugins = []);
  roles = ['none', 'dj', 'bouncer', 'manager', 'cohost', 'host', '_', 'volunteer', 'ambassador', 'leader', 'admin'];
  module('chatShowPending', {
    require: ['ChatHelper', 'user', 'Spinner'],
    setup: function(arg$){
      var replace;
      replace = arg$.replace;
      replace(ChatHelper, 'sendChat', function(){
        return chatShowPending.sendChat.apply(this, arguments);
      });
      return repeat(300000, function(){
        var d, i$, i, ref$, results$ = [];
        d = Date.now() - 300000;
        for (i$ = p0ne.pendingMessages.length - 1; i$ >= 0; --i$) {
          i = i$;
          if (p0ne.pendingMessages[i].timestamp < d) {
            if ((ref$ = p0ne.pendingMessages[i].el) != null) {
              ref$.remove();
            }
            results$.push(p0ne.pendingMessages.remove(i));
          }
        }
        return results$;
      });
    },
    update: function(){
      return ChatHelper.sendChat = function(){
        return chatShowPending.sendChat.apply(this, arguments);
      };
    },
    sendChat: function(e){
      var d, type;
      console.log("[sendChat]");
      if (this.chatCommand(e)) {
        return;
      }
      e = e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      _$context.trigger('chat:send', e);
      d = new Date;
      if ({
        '/me ': true,
        '/em ': true
      }[e.substr(0, 4)]) {
        e = e.substr(4);
        type = "emote pending";
      } else {
        type = "message pending";
      }
      e = e.replace(/\b(https?:\/\/[^\s\)\]]+)([\.,\?\!"']?)/g, '<a href="$1" target="_blank">$1</a>$2');
      p0ne_chat({
        message: e,
        type: type,
        un: user.username,
        uid: user.id,
        timestamp: d.getHours() + ":" + d.getMinutes(),
        pending: true
      });
      return true;
    }
  });
  module('p0ne_chat_plugins', {
    require: ['_$context'],
    setup: function(){
      return this.enable();
    },
    enable: function(){
      return _$context.onEarly('chat:receive', this.cb);
    },
    disable: function(){
      return _$context.off('chat:receive', this.cb);
    },
    cb: function(message){
      var i$, ref$, len$, plugin, onload;
      message.wasAtBottom == null && (message.wasAtBottom = chatIsAtBottom());
      for (i$ = 0, len$ = (ref$ = p0ne.chatPlugins).length; i$ < len$; ++i$) {
        plugin = ref$[i$];
        message = plugin(message, t) || message;
      }
      onload = '';
      if (message.wasAtBottom) {
        onload = 'onload="chatScrollDown()"';
      }
      return message = message.replace(/<a (.+?)>((https?:\/\/)(?:www\.)?(([^\/]+).+?))<\/a>/, function(all, pre, completeURL, protocol, domain, url){
        var i$, ref$, len$, plugin, that;
        arguments[4] = onload;
        for (i$ = 0, len$ = (ref$ = p0ne.chatLinkPlugins).length; i$ < len$; ++i$) {
          plugin = ref$[i$];
          if (that = plugin.apply(this, arguments)) {
            return that;
          }
        }
        return all;
      });
    }
  });
  chatWidth = 500;
  module('chatInlineImages', {
    setup: function(arg$){
      var add;
      add = arg$.add;
      return add(p0ne.chatLinkPlugins, this.plugin, {
        bound: true
      });
    },
    plugin: function(all, pre, completeURL, protocol, domain, url, onload){
      var that, rgx, repl, img;
      if (that = this.imgRegx[domain]) {
        rgx = that[0], repl = that[1];
        img = url.replace(rgx, repl);
        if (img !== url) {
          console.log("[inline-img]", "[" + plugin + "] " + protocol + url + " ==> " + protocol + img);
          return "<a " + pre + "><img src='" + protocol + img + "' class=p0ne_img " + onload + " onerror='imgError(this)'></a>";
        }
      }
      if (url.test(/^[^\#\?]+\.(?:jpg|jpeg|gif|png|webp|apng)(?:@\dx)?(?:\?.*|\#.*)?$/)) {
        console.log("[inline-img]", "[direct] " + url);
        return "<a " + pre + "><img src='" + url + "' class=p0ne_img " + onload + " onerror='imgError(this)'></a>";
      }
      console.log("[inline-img]", "NO MATCH FOR " + url + " (probably isn't an image)");
      return false;
    },
    imgRegx: {
      'imgur.com': [/^imgur.com\/(?:r\/\w+\/)?(\w\w\w+)/g, "i.imgur.com/$1.gif"],
      'prntscrn.com': [/^(prntscr.com\/\w+)(?:\/direct\/)?/g, "$1/direct"],
      'gyazo.com': [/^gyazo.com\/\w+/g, "i.$&/direct"],
      'dropbox.com': [/^dropbox.com(\/s\/[a-z0-9]*?\/[^\/\?#]*\.(?:jpg|jpeg|gif|png|webp|apng))/g, "dl.dropboxusercontent.com$1"],
      'pbs.twitter.com': [/^(pbs.twimg.com\/media\/\w+\.(?:jpg|jpeg|gif|png|webp|apng))(?:\:large|\:small)?/g, "$1:small"],
      'googleImg.com': [
        /^google\.com\/imgres\?imgurl=(.+?)(?:&|$)/g, function(arg$, src){
          return decodeURIComponent(url);
        }
      ],
      'imageshack.com': [
        /^imageshack\.com\/[fi]\/(\w\w)(\w+?)(\w)(?:\W|$)/, function(){
          return chatInlineImages.imageshackPlugin.apply(this, arguments);
        }
      ],
      'imageshack.us': [
        /^imageshack\.us\/[fi]\/(\w\w)(\w+?)(\w)(?:\W|$)/, function(){
          return chatInlineImages.imageshackPlugin.apply(this, arguments);
        }
      ]
    },
    imageshackPlugin: function(arg$, host, img, ext){
      ext = {
        j: 'jpg',
        p: 'png',
        g: 'gif',
        b: 'bmp',
        t: 'tiff'
      }[ext];
      return "https://imagizer.imageshack.us/a/img" + parseInt(host, 36) + "/" + ~~(Math.random() * 1000) + "/" + img + "." + ext;
    }
  });
  /* image plugins using plugCubed API (credits go to TATDK / plugCubed) */
  module('chatInlineImages_plugCubedAPI', {
    require: ['chatInlineImages'],
    setup: function(){
      return importAll$(chatInlineImages.imgRegx, this.imgRegx);
    },
    imgRegx: {
      'deviantart.com': [/^[\w\-\.]+\.deviantart.com\/(?:art\/|[\w:\-]+#\/)[\w:\-]+/, "https://api.plugCubed.net/redirect/da/$&"],
      'fav.me': [/^fav.me\/[\w:\-]+/, "https://api.plugCubed.net/redirect/da/$&"],
      'sta.sh': [/^sta.sh\/[\w:\-]+/, "https://api.plugCubed.net/redirect/da/$&"],
      'gfycat.com': [/^gfycat.com\/(.+)/, "https://api.plugCubed.net/redirect/gfycat/$1"]
    }
  });
  /* meme-plugins inspired by http://userscripts.org/scripts/show/154915.html (mirror: http://userscripts-mirror.org/scripts/show/154915.html while userscripts.org is down) */
  module('chatInlineImages_memes', {
    require: ['chatInlineImages'],
    setup: function(){
      return importAll$(chatInlineImages.imgRegx, this.imgRegx);
    },
    imgRegx: {
      'quickmeme.com': [/^(?:m\.)?quickmeme\.com\/meme\/(\w+)/, "i.qkme.me/$1.jpg"],
      'qkme.me': [/^(?:m\.)?qkme\.me\/(\w+)/, "i.qkme.me/$1.jpg"],
      'memegenerator.net': [/^memegenerator\.net\/instance\/(\d+)/, "http://cdn.memegenerator.net/instances/" + chatWidth + "x/$1.jpg"],
      'imageflip.com': [/^imgflip.com\/i\/(.+)/, "i.imgflip.com/$1.jpg"],
      'livememe.com': [/^livememe.com\/(\w+)/, "i.lvme.me/$1.jpg"],
      'memedad.com': [/^memedad.com\/meme\/(\d+)/, "memedad.com/memes/$1.jpg"],
      'makeameme.org': [/^makeameme.org\/meme\/(.+)/, "makeameme.org/media/created/$1.jpg"]
    }
  });
  module('chatYoutubeThumbnails', {
    setup: function(arg$){
      var add;
      add = arg$.add;
      add(p0ne.chatLinkPlugins, this.plugin);
      this.animate = this.animate.bind(this);
      return this.animate.isbound = true;
    },
    update: function(){
      if (!this.animate.isbound) {
        return this.animate = this.animate.bind(this);
      }
    },
    plugin: function(all, pre, completeURL, protocol, domain, url, onload){
      var yt;
      yt = /https?:\/\/(?:www\.)?(?:youtube(?:-nocookie)?\.com\/(?:[^\/]+\/.+\/|(?:v|embed|e)\/|.*(?:\?|&amp;)v=)|youtu\.be\/)([^"&?\/<>\s]{11})(?:&.*?|#.*?|)$/i.exec(url);
      if (yt && (yt = yt[1])) {
        console.log("[inline-img]", "[YouTube " + yt + "] " + url + " ==> http://i.ytimg.com/vi/" + yt + "/0.jpg");
        return "<a class=p0ne_yt data-yt-cid='" + yt + "' " + pre + "><div class=p0ne_yt_icon></div><div class=p0ne_yt_img " + onload + " style='background-image:url(http://i.ytimg.com/vi/" + yt + "/0.jpg)'></div>" + url + "</a>";
      }
      return false;
    },
    interval: -1,
    frame: 1,
    lastID: '',
    callback: {
      target: $('#chat'),
      event: 'mouseenter mouseleave',
      args: ['.p0ne_yt_img'],
      bound: true,
      callback: function(e){
        var id, img;
        clearInterval(this.interval);
        id = e.parentElement.dataset.ytCid;
        img = e.target;
        if (e.type === 'mouseenter') {
          if (id !== this.lastID) {
            this.frame = 1;
            this.lastID = id;
          }
          img.style.backgroundImage = "url(http://i.ytimg.com/vi/" + id + "/" + this.frame + ".jpg)";
          this.interval = repeat(1000, this.animate);
          return console.log("[p0ne_yt_preview]", "started", e, id, this.interval);
        } else {
          img.style.backgroundImage = "url(http://i.ytimg.com/vi/" + id + "/0.jpg)";
          return console.log("[p0ne_yt_preview]", "stopped");
        }
      }
    },
    animate: function(){
      console.log("[p0ne_yt_preview]", "showing 'http://i.ytimg.com/vi/" + id + "/" + this.frame + ".jpg'");
      this.frame = this.frame % 3 + 1;
      return img.style.backgroundImage = "url(http://i.ytimg.com/vi/" + id + "/" + this.frame + ".jpg)";
    }
  });
  /*@author jtbrinkmann aka. Brinkie Pie */
  /*@license https://creativecommons.org/licenses/by-nc-sa/4.0/ */
  /*
      based on BetterPonymotes https://ponymotes.net/bpm/
      note: even though this is part of the plug_p0ne script, it can also run on it's own with no dependencies 
      only the autocomplete feature will be missing without plug_p0ne
  
      for a ponymote tutorial see: http://www.reddit.com/r/mylittlepony/comments/177z8f/how_to_use_default_emotes_like_a_pro_works_for/
  */
  host = ((ref$ = window.p0ne) != null ? ref$.host : void 8) || "https://dl.dropboxusercontent.com/u/4217628/plug_p0ne";
  window.emote_map = {};
  /*== external sources ==*/
  $.getScript(host + "/bpm-resources.js");
  $('body').append("<link rel=\"stylesheet\" href=\"" + host + "/css/bpmotes.css\" type=\"text/css\">\n<link rel=\"stylesheet\" href=\"" + host + "/css/emote-classes.css\" type=\"text/css\">\n<link rel=\"stylesheet\" href=\"" + host + "/css/combiners-nsfw.css\" type=\"text/css\">\n<link rel=\"stylesheet\" href=\"" + host + "/css/gif-animotes.css\" type=\"text/css\">\n<link rel=\"stylesheet\" href=\"" + host + "/css/extracss-pure.css\" type=\"text/css\">\n<style>\n#chat-suggestion-items .bpm-emote {\n    max-width: 27px;\n    max-height: 27px\n}\n</style>");
  /*== constants ==*/
  _FLAG_NSFW = 1;
  _FLAG_REDIRECT = 2;
  /*
   * As a note, this regexp is a little forgiving in some respects and strict in
   * others. It will not permit text in the [] portion, but alt-text quotes don't
   * have to match each other.
   */
  /*                 [](/   <    emote   >   <    alt-text   >  )*/
  emote_regexp = /\[\]\(\/([\w:!#\/\-]+)\s*(?:["']([^"]*)["'])?\)/g;
  /*== auxiliaries ==*/
  /*
   * Escapes an emote name (or similar) to match the CSS classes.
   *
   * Must be kept in sync with other copies, and the Python code.
   */
  sanitize_emote = function(s){
    return s.toLowerCase().replace("!", "_excl_").replace(":", "_colon_").replace("#", "_hash_").replace("/", "_slash_");
  };
  lookup_core_emote = function(name, altText){
    var data, nameWithSlash, parts, flag_data, tag_data, flags, source_id, size, is_nsfw, is_redirect, tags, start, str, base;
    data = emote_map[name];
    if (!data) {
      return null;
    }
    nameWithSlash = "/" + name;
    parts = data.split('|');
    flag_data = parts[0];
    tag_data = parts[1];
    flags = parseInt(flag_data.slice(0, 1), 16);
    source_id = parseInt(flag_data.slice(1, 3), 16);
    size = parseInt(flag_data.slice(3, 7), 16);
    is_nsfw = flags & _FLAG_NSFW;
    is_redirect = flags & _FLAG_REDIRECT;
    tags = [];
    start = 0;
    while ((str = tag_data.slice(start, start + 2)) !== "") {
      tags.push(parseInt(str, 16));
      start += 2;
    }
    if (is_redirect) {
      base = parts[2];
    } else {
      base = name;
    }
    return {
      name: nameWithSlash,
      is_nsfw: !!is_nsfw,
      source_id: source_id,
      source_name: sr[source_id],
      max_size: size,
      tags: tags,
      css_class: "bpmote-" + sanitize_emote(name),
      base: base,
      altText: altText
    };
  };
  convert_emote_element = function(info, parts){
    var title, flags, i$, len$, i, flag;
    title = (info.name + " from " + info.source_name).replace(/"/g, '');
    flags = "";
    for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
      i = i$;
      flag = parts[i$];
      if (i > 0) {
        /* Normalize case, and forbid things that don't look exactly as we expect */
        flag = sanitize_emote(flag.toLowerCase());
        if (!/\W/.test(flag)) {
          flags += " bpflag-" + flag;
        }
      }
    }
    if (info.is_nsfw) {
      if (info.is_nsfw) {
        title = "[NSFW] " + title;
      }
      flags += " bpm-nsfw";
    }
    return "<span class='bpflag-in bpm-emote " + info.css_class + " " + flags + "' title='" + title + "' data-bpm_emotename='" + info.name + "'>" + (info.altText || '') + "</span>";
  };
  window.bpm = function(str){
    return str.replace(emote_regexp, function(_, parts, altText){
      var name, info;
      parts = parts.split('-');
      name = parts[0];
      info = lookup_core_emote(name, altText);
      if (!info) {
        return _;
      } else {
        return convert_emote_element(info, parts);
      }
    });
  };
  if ((ref$ = window.p0ne) != null && ref$.chatPlugins) {
    /* add BPM as a p0ne chat plugin */
    (ref$ = window.p0ne.chatPlugins)[ref$.length] = window.bpm;
  } else {
    (function(){
      /* add BPM as a standalone script */
      var module, ref$, id, ref1$;
      if (!window._$context) {
        module = window.require.s.contexts._.defined['b1b5f/b8d75/c3237'];
        if (module && ((ref$ = module._events) != null && ref$['chat:receive'])) {
          window._$context = module;
        } else {
          for (id in ref$ = require.s.contexts._.defined) {
            module = ref$[id];
            if (module && ((ref1$ = module._events) != null && ref1$['chat:receive'])) {
              window._$context = module;
              break;
            }
          }
        }
      }
      return window._$context._events['chat:receive'].unshift({
        callback: function(d){
          d.message = bpm(d.message);
        }
      });
    })();
  }
  $(window).one('p0ne_emotes_map', function(){
    var cb;
    console.log("== Ponymotes loaded ==");
    /* ponify old messages */
    $('#chat .text').html(function(){
      return window.bpm(this.innerHTML);
    });
    /* add autocomplete if/when plug_p0ne and plug_p0ne.autocomplete are loaded */
    cb = function(){
      return typeof addAutocompletion === 'function' ? addAutocompletion({
        name: "Ponymotes",
        data: Object.keys(emote_map),
        pre: "[]",
        check: function(str, pos){
          var temp;
          if (!str[pos + 2] || str[pos + 2] === "(" && (!str[pos + 3] || str[pos + 3] === "(/")) {
            temp = /^\[\]\(\/([\w#\\!\:\/]+)(\s*["'][^"']*["'])?(\))?/.exec(str.substr(pos));
            if (temp) {
              this.data = temp[2] || '';
              return true;
            }
          }
          return false;
        },
        display: function(items){
          var emote;
          return (function(){
            var i$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = items).length; i$ < len$; ++i$) {
              emote = ref$[i$];
              results$.push({
                value: "[](/" + emote + ")",
                image: bpm("[](/" + emote + ")")
              });
            }
            return results$;
          }());
        },
        insert: function(suggestion){
          return suggestion.substr(0, suggestion.length - 1) + "" + this.data + ")";
        }
      }) : void 8;
    };
    if (window.addAutocompletion) {
      return cb();
    } else {
      return $(window).one('p0ne_autocomplete', cb);
    }
  });
  /*@author jtbrinkmann aka. Brinkie Pie */
  /*@license https://creativecommons.org/licenses/by-nc/4.0/ */
  /*
  module ||= (name, {callback:{target, event, callback}}) ->
      # module() for the poor
      if not window[name]
          target.on event, -> window[name] ...
      window[name] = callback
  requireHelper = ({id, test, fallback}:a) ->
      if typeof a == \function
          test = a
      module = require.s.contexts._.defined[id] if id
      if module and test module
          module.id ||= id
          return module
      else
          for id, module of require.s.contexts._.defined when module
              if test module, id
                  module.id ?= id
                  console.warn "[requireHelper] module '#{module.name}' updated to ID '#id'"
                  return module
          return fallback
  */
  $("<link href='" + p0ne.host + "/p0ne.notif.css' rel='stylesheet' type='text/css'>").appendTo('body');
  icon = function(name){
    return "<i class='icon icon-" + name + "'></i>";
  };
  mediaURL = function(media){
    if (media.format === 1) {
      return "http://youtube.com/watch?v=" + media.cid;
    } else if (media.format === 2) {
      return "https://soundcloud.com/" + media.author + "/" + media.title.replace(/[^\s\w]+/g, '').replace(/\s+/g, '-');
    }
  };
  module('songNotifications', {
    callback: {
      target: API,
      event: API.ADVANCE,
      callback: function(d){
        var skipped, skipper, reason, $div, html, media, ytID;
        skipped = false;
        skipper = reason = "";
        window.d = d;
        console.log("[DJ ADVANCE]", d);
        $div = $('<div>').addClass('update').addClass('song-notif');
        html = "";
        /*
        if d.lastPlay
            html += "
                <div class='song-notif-last'>
                    <div class='song-stats'>
                        <span class='song-woots'>#{icon \history-positive}#{d.lastPlay.score.positive} </span>
                        <span class='song-mehs'>#{icon \history-negative}#{d.lastPlay.score.negative} </span>
                        <span class='song-grabs'>#{icon \history-grabs}#{d.lastPlay.score.grabs}</span>
                    </div>
                </div>
            " #note: the spaces in .song-stats are obligatory! otherwise justify won't work
            if skipped
                html += "<div class='song-skipped'>"
                html +=     "<span class='song-skipped-by'>#skipper</span>"
                html +=     "<span class='song-skipped-reason'>#reason</span>" if reason
                html += "</div>"
        */
        if (d.media) {
          media = d.lastPlay.media;
          if (media.format === 1) {
            ytID = "data-yt-id='" + media.id + "' data-yt-cid='" + media.cid + "'";
          } else {
            ytID = "";
          }
          html += "<div class='song-notif-next'><div class='song-thumb-wrapper'><img class='song-thumb' " + ytID + " src='" + media.image + "' /><div class='song-add' " + ytID + "><i class='icon icon-add'></i></div><a class='song-open' href='" + mediaURL(media) + "' target='_blank'><i class='icon icon-chat-popout'></i></a></div><div class='song-dj'></div><b class='song-title'></b><span class='song-author'></span></div>";
        }
        $div.html(html);
        $div.find('.song-dj').text(d.dj.username);
        $div.find('.song-title').text(d.media.title).prop('title', d.media.title);
        $div.find('.song-author').text(d.media.author);
        return appendChat($div);
      }
    }
  });
  window.popup = requireHelper({
    name: 'pop-menu',
    id: 'de369/d86c0/b0607/e1fa4',
    test: function(it){
      return it.className === 'pop-menu';
    }
  });
  $('body').off('click', '.song-add', window.fn);
  wrap = function(obj){
    obj.get = function(name){
      var a;
      console.log("[get]", name, this[name], arguments.callee.caller.arguments);
      if (name === 'media') {
        return this;
      }
      a = this[name];
      if (a) {
        return typeof a === 'object' ? wrap(a) : a;
      } else {
        return null;
      }
    };
    return obj;
  };
  window.fn = function(){
    var el, msg, id, msgOffset, obj;
    el = $(this);
    msg = el.closest(".song-notif");
    id = el.data('yt-id');
    msgOffset = msg.offset();
    el.offset = function(){
      return {
        top: msgOffset.top + 13,
        left: msgOffset.left + 12
      };
    };
    obj = [wrap({
      id: id,
      format: 1
    })];
    importAll$(window, {
      el: el,
      obj: obj,
      msg: msg,
      msgOffset: msgOffset
    });
    popup.isShowing = false;
    return popup.show(el, obj);
  };
  return $('body').on('click', '.song-add', window.fn);
});
function importAll$(obj, src){
  for (var key in src) obj[key] = src[key];
  return obj;
}